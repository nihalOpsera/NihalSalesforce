{"version":3,"sources":["webpack:///adminService.js","webpack:///webpack/bootstrap 1c620c80e17b918674e8","webpack:///./adminService/docGenAdminService.module.js","webpack:///delegated ./node_modules/angular/index.js from dll-reference vendor_lib","webpack:///external \"vendor_lib\"","webpack:///./adminService/i18nService.js","webpack:///./adminService/remoteService.js","webpack:///./adminService/utilService.js","webpack:///./adminService/actionQueueService.js","webpack:///./adminService/queueWrapperService.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","angular","provider","service","config","vendor_lib","i18nService","i18nData","buildNumberSettings","template","precision","settings","symbol","isSymbolBefore","separator","groupLength","decimal","isNumber","groupingExp","undefined","templateRegex","matches","match","shift","length","regexpStr","RegExp","buildDateSettings","dateTemplate","ordering","forEach","matchIndex","loopIndex","digits","component","str","numVal","Number","i","paddingExp","separatorExp","join","currencySettings","currencyTemplate","currency","quantitySettings","quantityTemplate","quantity","dateSettings","timeZoneOffset","Date","getTimezoneOffset","this","CustomLabel","CustomField","dateFormat","locale","$get","setCustomLabel","newLabels","extend","setCustomField","newFields","setDateFormat","newFormat","setLocale","newLocale","setPrecision","key","value","isDefined","setDateTemplate","newTemplate","setCurrencyTemplate","setQuantityTemplate","RemoteServiceFactory","$q","$log","$window","RemoteService","actionsMap","redirectOnFail","RemoteActions","initRemoteActionFunctions","actionKey","isProp","isStr","hasOwnProperty","actionConfig","getRemoteActionConfig","createRemoteActionFunction","actionConf","isString","actionName","skipLoader","isObject","actionFunction","invokeRemoteAction","arguments","actionParams","deferred","errorMessage","remoteActionWithParams","resolver","remotingParams","defer","setRemoteServiceCount","error","reject","promise","nextArg","argIndex","push","result","event","status","debug","timeTaken","queryCount","timeDetail","resolve","message","isLoggedOut","toLowerCase","indexOf","location","href","buffer","escape","timeout","Visualforce","remoting","Manager","invokeAction","apply","ex","incrementFlag","trackAllRemoteCalls","incrementRemoteServiceCount","decrementRemoteServiceCount","setRemoteActions","newActions","setRedirectLocation","newLocation","setTrackAllRemoteCalls","isEnabled","$inject","_","frequencyConstants","FREQUENCY_HOURLY","FREQUENCY_DAILY","FREQUENCY_WEEKLY","FREQUENCY_MONTHLY","FREQUENCY_QUARTERLY","FREQUENCY_HALFYEARLY","FREQUENCY_YEARLY","priceTypesConstants","PRICETYPE_ONETIME","PRICETYPE_RECURRING","PRICETYPE_USAGE","PRICETYPE_INCLUDED_USAGE","round","roundExpPos","roundExpNeg","Math","isBetween","minVal","maxVal","betweenVal","strictly","minSatisfied","maxSatisfied","stringFormat","baseString","inserts","isArray","stringGroups","split","formattedString","isInsert","insertIndex","nextInsert","stringIndex","parseInt","isEmpty","obj","newUTCDate","year","month","date","newDate","setUTCHours","setUTCFullYear","setUTCMonth","setUTCDate","addDays","days","computeEndDate","startDate","term","frequency","newEndDate","setDate","getDate","computeEndDateByMonths","frequencyInMonths","months","setMonth","getMonth","dateToFindDays","daysInMonths","daysInMonth","getFullYear","remainingTerms","extraDays","reorderArray","array","callback","isFunction","spliceIdx","idx","culled","splice","removeTempUIAttributes","Object","keys","startsWith","validateEndDate","now","getTime","validateDate","date_regex","isUndefined","toString","trim","test","uniq","inputArray","tempArray","tempObj","intersection","actionArr","sObjectFromField","contextSO","fieldAPIName","path","curObject","max","createPopup","product","infoURL","productInformationList","InformationType__c","FileId__c","EmbedCode__c","ContentUrl__c","header","Name","isEmbed","url","infoModal","window","open","document","write","focus","registerAction","functionObject","precedence","hashVal","maxPrecedence","Function","min","hashObject","hashedActionsMap","action","isScheduled","objectToHash","hash","char","charCodeAt","scheduleAction","tail","actionIndex","nextActionKey","resultPromises","queuedResult","queueByPrecedence","then","fireSync","all","actionInfo","scheduledActionQueue","index","nextActionInfo","isProcessingActions","processingActions","sentTime","logTime","info","toGMTString","fireScheduledActionQueue","receivedTime","delta","reason","when","nextPromise","queue","pendingDeferreds","pendingPromises","allResults","dfdIndex","$provide","decorator","$delegate","$rootScope","pendingPromisses","pendingRemoteServiceCount","origDefer","finally","getPendingRemoteServiceCount","getPendingPromisses"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAAUI,EAAQD,EAASH,GAEhCI,EAAOD,QAAUH,EAAoB,IAKhC,SAAUI,EAAQD,EAASH,IEnDjC,WACA,YACAA,GAAA,GACAI,EAAAD,QAAAQ,QAAAP,OAAA,2BACAQ,SAAA,cAAAZ,EAAA,IACAY,SAAA,gBAAAZ,EAAA,IACAa,QAAA,cAAAb,EAAA,IACAa,QAAA,qBAAAb,EAAA,IACAc,OAAAd,EAAA,QF2DM,SAAUI,EAAQD,EAASH,GGnEjCI,EAAAD,QAAAH,EAAA,OHyEM,SAAUI,EAAQD,GIzExBC,EAAAD,QAAAY,YJ+EM,SAAUX,EAAQD,IK/ExB,WACAC,EAAAD,SAAA,WA+DA,QAAAa,GAAAC,GAQA,QAAAC,GAAAC,EAAAC,GACA,GAAAC,IACAC,OAAA,GACAC,gBAAA,EACAC,UAAA,IACAC,YAAA,EACAC,QAAA,IACAN,UAAAT,QAAAgB,SAAAP,KAAA,EACAQ,YAAAC,QAUAC,EAAA,oFACAC,EAAAZ,EAAAa,MAAAF,EACAC,KAEAA,EAAAE,QAEAF,EAAA,IACAV,EAAAC,OAAAS,EAAA,GACAV,EAAAE,gBAAA,IAGAF,EAAAC,OAAAS,EAAA,GACAV,EAAAE,gBAAA,GAIAF,EAAAG,UAAAO,EAAA,GACAV,EAAAI,YAAAM,EAAA,GAAAG,OACAb,EAAAK,QAAAK,EAAA,GAUA,IAAAI,GAAA,WAA2Bd,EAAAI,YAAA,cAA8CJ,EAAAI,YAAA,sBAEzE,OADAJ,GAAAO,YAAA,GAAAQ,QAAAD,GACAd,EAUA,QAAAgB,GAAAC,GACA,GAAAjB,IACAG,UAAA,IACAe,UAAA,kBACAX,YAAAC,QASAC,EAAA,gDACAC,EAAAO,EAAAN,MAAAF,EACAC,KAEAA,EAAAE,QACAZ,EAAAG,UAAAO,EAAA,SACA,OAAAS,QAAA,SAAAC,EAAAC,GACA,GAAAC,GAAAZ,EAAAU,GACAG,EAAA,GACAC,EAAA,GACAC,EAAAC,OAAAJ,EAEAC,GADAE,GAAA,GACA,IAEOA,GAAA,GACP,IAGA,GAQA,QAAAE,GAAA,EAAqBA,EAAAL,EAAAT,OAAmBc,IACxCH,GAAAD,CAGAvB,GAAAkB,SAAAG,GAAAG,IAWA,IAAAI,GAAA,OACAC,EAAAD,EAAA,KAAA5B,EAAAG,UAAA,IAAAyB,EACAd,GAAA,IAAAc,EAAA,aAAgDC,EAAA,cAA4BA,EAAA,cAA6BD,EAAA,KAAAE,KAAA,GAEzG,OADA9B,GAAAO,YAAA,GAAAQ,QAAAD,GACAd,EA3HA,GAAAR,GAAAI,CAKA,OAJAJ,GAAAuC,iBAAAlC,EAAAD,EAAAoC,iBAAApC,EAAAG,UAAAkC,UACAzC,EAAA0C,iBAAArC,EAAAD,EAAAuC,iBAAAvC,EAAAG,UAAAqC,UACA5C,EAAA6C,aAAArB,EAAApB,EAAAqB,cACAzB,EAAA8C,eAAA,OAAAC,OAAAC,oBAAA,IACAhD,EAnEA,GAAAD,GAAAkD,KAEA7C,GACA8C,eACAC,eACAC,WAAA,aACA3B,aAAA,aACAe,iBAAA,YACAG,iBAAA,WACApC,WACAkC,SAAA,EACAG,SAAA,GAEAS,OAAA,QAGAJ,MAAAK,KAAA,WACA,UAAAnD,GAAAC,IAGAL,EAAAwD,eAAA,SAAAC,GACA1D,QAAA2D,OAAArD,EAAA8C,YAAAM,IAEAzD,EAAA2D,eAAA,SAAAC,GACA7D,QAAA2D,OAAArD,EAAA+C,YAAAQ,IAEA5D,EAAA6D,cAAA,SAAAC,GACAA,IACAzD,EAAAgD,WAAAS,IAGA9D,EAAA+D,UAAA,SAAAC,GACAA,IACA3D,EAAAiD,OAAAU,IAGAhE,EAAAiE,aAAA,SAAAC,EAAAC,GACA,gBAAAD,IAAAnE,QAAAqE,UAAAD,GACA9D,EAAAG,UAAA0D,GAAA/B,OAAAgC,GAEI,gBAAAD,IACJnE,QAAA2D,OAAArD,EAAAG,UAAA0D,IAIAlE,EAAAqE,gBAAA,SAAAC,GACAA,IACAjE,EAAAqB,aAAA4C,IAGAtE,EAAAuE,oBAAA,SAAAD,GACAA,IACAjE,EAAAoC,iBAAA6B,IAGAtE,EAAAwE,oBAAA,SAAAF,GACAA,IACAjE,EAAAuC,iBAAA0B,UL6NM,SAAU9E,EAAQD,IMzRxB,WACAC,EAAAD,SAAA,WAuBA,QAAAkF,GAAAC,EAAAC,EAAAC,GACA,UAAAC,GAAAH,EAAAC,EAAAC,EAAAE,EAAAC,GAQA,QAAAF,GAAAH,EAAAC,EAAAC,EAAAI,EAAAD,GAMA,QAAAE,KACA,GAAAC,GAAAC,EAAAC,CACA,KAAAF,IAAAF,GACAG,EAAAH,EAAAK,eAAAH,GACAE,EAAA,gBAAAF,GACAC,GAAAC,IACAE,aAAAC,EAAAL,GACAjF,EAAAiF,GAAAM,EAAAF,eAUA,QAAAC,GAAAL,GACA,GAAAhF,KAEA,IAAAH,QAAAqE,UAAAY,EAAAE,IAAA,CACA,GAAAO,GAAAT,EAAAE,EACAnF,SAAA2F,SAAAD,IACAvF,EAAAyF,WAAAF,EACAvF,EAAA0F,YAAA,GAEqB7F,QAAA8F,SAAAJ,KACrBvF,EAAAyF,WAAA5F,QAAAqE,UAAAqB,EAAAE,YAAAF,EAAAE,WAAA,KACAzF,EAAA0F,aAAA7F,QAAAqE,UAAAqB,EAAAG,aAAAH,EAAAG,YAKA,MAAA1F,GAYA,QAAAsF,GAAAF,GACA,GAAAQ,GAAA,WACA,MAAAC,GAAAT,EAAAU,WAGA,OAAAF,GAoBA,QAAAC,GAAAT,EAAAW,GAIA,GAAAC,GAAAC,EAAAC,EAAAC,EAAAC,EAAAX,CAMA,IALAO,EAAAxB,EAAA6B,QACAZ,EAAAL,EAAAK,WAEAa,EAAAlB,GAAA,IAEAK,GAAA,gBAAAA,GAIA,MAHAQ,GAAA,+DACAxB,EAAA8B,MAAAN,GACAD,EAAAQ,OAAAP,GACAD,EAAAS,OAIAP,IAAAT,EACA,QAAAiB,GAAAC,EAAA,EAA+CA,EAAAZ,EAAA3E,OAAgCuF,IAC/ED,EAAAX,EAAAY,GAQAT,EAAAU,KAAAF,EAIAP,GAAA,SAAAU,EAAAC,GACA,GAAAA,EAAAC,OACA,OAAAF,IACApC,EAAAuC,MAAA,aAAAvB,EAAA,kBACAoB,EAAAI,UAAA,2BACAJ,EAAAK,YAEAL,EAAAM,YACA1C,EAAAuC,MAAA,eAAAvB,EAAAoB,EAAAM,aAIAnB,EAAAoB,QAAAP,OAEqB,CACrBZ,EAAA,4CAAAR,EACAhB,EAAA8B,MAAAN,EAAAF,EAAAe,EAAAO,QAEA,IAAAC,GAAAR,EAAAO,QAAAE,cAAAC,QAAA,YACAF,IAAAzC,IACAH,EAAA+C,SAAAC,KAAA7C,GAGAmB,EAAAQ,OAAAM,GAIAR,EAAAlB,GAAA,IAEAc,EAAAU,KAAAT,GAGAC,GACAuB,QAAA,EACAC,QAAA,EACAC,QAAA,MAEA3B,EAAAU,KAAAR,EAGA,KACA0B,YAAAC,SAAAC,QAAAC,aAAAC,MAAAJ,YAAAC,SAAAC,QAAA9B,GAEiB,MAAAiC,GACjBlC,EAAA,2CAAAR,EACAhB,EAAA8B,MAAAN,EAAAF,EAAAoC,GACAnC,EAAAQ,OAAAP,GAGA,MAAAD,GAAAS,QAQA,QAAAH,GAAAlB,EAAAgD,GAEAhD,EAAAM,aAAA2C,IACAD,EACA5D,EAAA8D,8BAGA9D,EAAA+D,+BA3KA,GAAAxI,KAGA,OADAgF,KACAhF,EAlCA,GAAAD,GAAAkD,KACA4B,KACAC,EAAA,IACAwD,GAAA,CAEAvI,GAAA0I,iBAAA,SAAAC,GAGA,MADA5I,SAAA2D,OAAAoB,EAAA6D,GACA3I,GAGAA,EAAA4I,oBAAA,SAAAC,GAEA,MADA9D,KAAA8D,KACA7I,GAGAA,EAAA8I,uBAAA,SAAAC,GAEA,MADAR,GAAAQ,EACA/I,GAQAyE,EAAAuE,SAAA,uBAEA9F,KAAAK,KAAAkB,QNydM,SAAUjF,EAAQD,IOxfxB,WACAC,EAAAD,SAAA,kBAAA0J,GACA,GAAAhJ,GAAAiD,IA2XA,OAzXAjD,GAAAiJ,oBACAC,iBAAA,SACAC,gBAAA,QACAC,iBAAA,SACAC,kBAAA,UACAC,oBAAA,YACAC,qBAAA,cACAC,iBAAA,UAGAxJ,EAAAyJ,qBACAC,kBAAA,WACAC,oBAAA,YACAC,gBAAA,QACAC,yBAAA,kBAWA7J,EAAA8J,MAAA,SAAA5F,EAAA3D,GACAA,MAAA,CACA,IAAAwJ,GAAA,KAAAxJ,EACAyJ,EAAA,KAAAzJ,CACA,OAAA2B,QAAA+H,KAAAH,MAAA5F,EAAA6F,GAAAC,IAeAhK,EAAAkK,UAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAxK,QAAAgB,SAAAuJ,GACA,QAGA,IAAAE,GAAAC,CAUA,OATAF,IAKAC,GAAAzK,QAAAgB,SAAAqJ,IAAAE,EAAAF,EACAK,GAAA1K,QAAAgB,SAAAsJ,IAAAC,EAAAD,IALAG,GAAAzK,QAAAgB,SAAAqJ,IAAAE,GAAAF,EACAK,GAAA1K,QAAAgB,SAAAsJ,IAAAC,GAAAD,GAOAG,GAAAC,GAYAxK,EAAAyK,aAAA,SAAAC,EAAAC,GACA,IAAAD,EACA,QAGA,KAAA5K,QAAA8K,QAAAD,GACA,MAAAD,EAQA,QALAG,GAAAH,EAAAI,MAAA,aACAC,EAAA,GACAC,GAAA,EACAC,EAAA,EACAC,EAAA,GACAC,EAAA,EAAqCA,EAAAN,EAAAxJ,OAAmC8J,IACxEH,GACAA,GAAA,EACAC,EAAAG,SAAAP,EAAAM,IACAD,EAAAD,EAAAN,EAAAtJ,OAAAsJ,EAAAM,GAAA,GACAF,GAAAG,IAGAF,GAAA,EACAD,GAAAF,EAAAM,GAKA,OAAAJ,IAQA/K,EAAAqL,QAAA,SAAAC,GACA,OAAAxL,QAAAqE,UAAAmH,IAAA,OAAAA,MACAxL,QAAA8K,QAAAU,IAAA,IAAAA,EAAAjK,QAAA,KAAAiK,IAoBAtL,EAAAuL,WAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAA,GAAA5I,KAcA,OAbA4I,GAAAC,YAAA,OACA9L,QAAAgB,SAAA0K,IACAG,EAAAE,eAAAL,GAGA1L,QAAAgB,SAAA2K,IACAE,EAAAG,YAAAL,GAGA3L,QAAAgB,SAAA4K,IACAC,EAAAI,WAAAL,GAGAC,GAUA3L,EAAAgM,QAAA,SAAAN,EAAAO,GACA,MAAAP,GAAA,MAAAO,GAUAjM,EAAAkM,eAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAA,GAAAvJ,MAAAoJ,EAmCA,OA/BAG,GAFAD,IAAArM,EAAAiJ,mBAAAC,iBAEAoD,EAAAC,QAAAD,EAAAE,UAAA,KAAAJ,GAEaC,IAAArM,EAAAiJ,mBAAAE,gBAEbmD,EAAAC,QAAAD,EAAAE,UAAAJ,GAEaC,IAAArM,EAAAiJ,mBAAAG,iBAEbkD,EAAAC,QAAAD,EAAAE,UAAA,EAAAJ,GAEaC,IAAArM,EAAAiJ,mBAAAI,kBAEbrJ,EAAAyM,uBAAAN,EAAAC,EAAA,GAEaC,IAAArM,EAAAiJ,mBAAAK,oBAEbtJ,EAAAyM,uBAAAN,EAAAC,EAAA,GAEaC,IAAArM,EAAAiJ,mBAAAM,qBAEbvJ,EAAAyM,uBAAAN,EAAAC,EAAA,GAEaC,IAAArM,EAAAiJ,mBAAAO,iBAEbxJ,EAAAyM,uBAAAN,EAAAC,EAAA,IAIAD,GAaAnM,EAAAyM,uBAAA,SAAAN,EAAAC,EAAAM,GACA,GAAAC,GAAAP,EAAAM,EAEAJ,EAAA,GAAAvJ,MAAAoJ,EACAG,KAAAM,SAAAN,EAAAO,WAAAF,EAEA,IAAAG,GAAA,GAAA/J,MAAAuJ,EACAQ,KAAAP,QAAAO,EAAAN,UAAA,EAEA,IAAAO,GAAA/M,EAAAgN,YAAA,GAAAjK,MAAA+J,GAAAG,cAAA,GAAAlK,MAAA+J,GAAAD,YACAK,EAAAd,EAAAM,EAAAC,EACAQ,EAAAlD,KAAAH,MAAAoD,EAAAH,EAKA,OAHAT,GAAA,GAAAvJ,MAAAuJ,GACAA,IAAAC,QAAAD,EAAAE,WAAAW,EAAA,KAWAnN,EAAAoN,aAAA,SAAAC,EAAAC,GACA,GAAAtE,EAAA4B,QAAAyC,MAAA,OAAAA,EAAAhM,QAAA2H,EAAAuE,WAAAD,MAAA,GAMA,OAFAE,MAEArL,EAAA,EAA2BA,EAAAkL,EAAAhM,OAAkBc,IAE7CA,EAAA,GAAAmL,EAAAD,EAAAlL,KACAqL,EAAA3G,KAAA1E,EAIAqL,GAAA7L,QAAA,SAAA8L,GACA,GAAAC,GAAAL,EAAAM,OAAAF,EAAA,EACAJ,GAAAM,OAAA,IAAAD,EAAA,QAUA1N,EAAAgN,YAAA,SAAAxB,EAAAC,GACA,UAAA1I,MAAAyI,EAAAC,EAAA,GAAAe,WAGAxM,EAAA4N,uBAAA,SAAAtC,GACAuC,OAAAC,KAAAxC,GAAA3J,QAAA,SAAAsC,GACA+E,EAAA+E,WAAA9J,EAAA,OAAA+E,EAAA+E,WAAA9J,EAAA,YACAqH,GAAArH,GACiBnE,QAAA8F,SAAA0F,EAAArH,KACjBjE,EAAA4N,uBAAAtC,EAAArH,OAKAjE,EAAAgO,gBAAA,SAAAtC,GACA,GAAAuC,GAAA,GAAAlL,KACA,SAAAkL,EAAAC,UAAAxC,IAMA1L,EAAAmO,aAAA,SAAAzC,GACA,GAAA0C,GAAA,yDACA,QAAAtO,QAAAuO,YAAA3C,IAAA,OAAAA,MAEaA,EAAA4C,WAAAC,OAAAlN,OAAA,KAEA+M,EAAAI,KAAA9C,KAMb1L,EAAAyO,KAAA,SAAAC,GACA,GAAAC,MACAC,IAOA,OANA5F,GAAArH,QAAA+M,EAAA,SAAAxK,EAAAD,GACA2K,EAAA1K,EAAA1E,MACAmP,EAAA9H,KAAA3C,GACA0K,EAAA1K,EAAA1E,IAAA0E,EAAA1E,MAGAmP,GAGA3O,EAAA6O,aAAA,SAAAH,GACA,GAAAC,KAIA,OAHA3F,GAAArH,QAAA+M,EAAA,SAAAxK,EAAAD,GACA0K,EAAA9H,KAAA3C,EAAA4K,aAEA9F,EAAA6F,aAAA1G,MAAAa,EAAA2F,IASA3O,EAAA+O,iBAAA,SAAAC,EAAAC,GAIA,OAFAC,GAAAD,EAAAnE,MAAA,KACAqE,EAAAH,EACA7M,EAAA,EAAAiN,EAAAF,EAAA7N,OAAA,EAAkDc,EAAAiN,EAASjN,IAC3D,8BAAAgN,IACAA,IAAAD,EAAA/M,IAIA,OAAAgN,IAOAnP,EAAAqP,YAAA,SAAAC,GACA,GAAAC,GAAA,EACA,IAAAD,EAAAE,uBAAAnO,OAAA,GACA,iBAAAiO,EAAAE,uBAAA,GAAAC,mBACAF,EAAA,sCAAAD,EAAAE,uBAAA,GAAAE,UAEiB,iBAAAJ,EAAAE,uBAAA,GAAAC,mBACjBF,EAAAD,EAAAE,uBAAA,GAAAG,aAEiB,eAAAL,EAAAE,uBAAA,GAAAC,qBACjBF,EAAAD,EAAAE,uBAAA,GAAAI,cAOA,IAAAC,GAAAP,EAAAE,uBAAAnO,OAAA,EAAAiO,EAAAE,uBAAA,GAAAM,KAAA,GACAC,EAAA,iBAAAT,EAAAE,uBAAA,GAAAC,kBAEA,SAAAF,GAAA,OAAAA,EACA,QAGA,IAAAS,GAAAD,EAAA,GAAAR,EAEAU,EAAAC,OAAAC,KAAAH,EAAA,mEACAD,KACAE,EAAAG,SAAAC,MAAA,yDACAJ,EAAAG,SAAAC,MAAA,qBAAAR,EAAA,SACAI,EAAAG,SAAAC,MAAAd,GACAU,EAAAG,SAAAC,MAAA,4BAEAH,OAAAI,OACAL,EAAAK,UAIAtQ,QPmgBM,SAAUT,EAAQD,IQh4BxB,WACAC,EAAAD,SAAA,qBAAAmF,EAAAC,GAsCA,QAAA6L,GAAAC,EAAAC,EAAAxL,GACA,GAAAyL,GACAtB,EAAA5O,EAAAmQ,aACA,OAAAH,aAAAI,WASAH,EAJA3Q,QAAAgB,SAAA2P,GAIAxG,KAAA4G,IAAAJ,EAAArB,GAHAA,EAMAsB,EAAAI,EAAA7L,IAAAuL,GAGAO,EAAAL,IACAM,OAAAR,EACAC,aACAQ,aAAA,GAGAjR,GApBAA,EA+BA,QAAA8Q,GAAAI,GACA,GAAAlP,GAAAkP,EAAA5C,WACA6C,EAAA,IACA,KAAAhP,EAAA,EAAuBA,EAAAH,EAAAX,OAAgBc,IACvCiP,KAAApP,EAAAqP,WAAAlP,GACAgP,MAAA,GAAAA,EAAAC,IAGA,OAAAD,GAiBA,QAAAG,GAAArM,GACA,GAAAnF,QAAAuO,YAAApJ,IAAA,OAAAA,EACA,MAAAsM,EAGA,IAAAzC,KACAhP,SAAA8K,QAAA3F,GACA6J,EAAA7J,EAGA6J,EAAAjI,KAAA5B,EAGA,IAAAuM,GAAAC,EACAC,IACA,KAAAF,EAAA,EAAiCA,EAAA1C,EAAAzN,OAAgCmQ,GAAA,EACjEC,EAAA3C,EAAA0C,GACAG,aAAAC,EAAAH,GACAE,cACAD,EAAA7K,KAAA8K,cAEAV,IACAA,GAAA,EACAM,IAAAM,KAAAC,GAKA,WAAAJ,EAAArQ,OACAqQ,EAAA,GAEaA,EAAArQ,OAAA,EACboD,EAAAsN,IAAAL,GAGAH,EASA,QAAAK,GAAA3M,GACA,IAAAA,EACA,QAIA,IAAAyL,GAAAI,EAAA7L,GACA+M,EAAAjB,EAAAL,EAEA,KAAAsB,EACA,QAEa,IAAAA,EAAAf,YACb,MAAAe,GAAA/L,SAAAS,OAKA,QADA8K,GAAAS,EAAA5Q,OACA6Q,EAAA,EAA+BA,EAAAD,EAAA5Q,SAAqC6Q,EAAA,CACpE,GAAAC,GAAAF,EAAAC,EACA,IAAAF,EAAAvB,WAAA0B,EAAA1B,WAAA,CACAe,EAAAU,CACA,QASA,MAHAD,GAAAtE,OAAA6D,EAAA,EAAAQ,GACAA,EAAAf,aAAA,EACAe,EAAA/L,SAAAxB,EAAA6B,QACA0L,EAAA/L,SAAAS,QASA,QAAA0L,KACA,MAAAC,GAaA,QAAAP,KACAb,GAAA,EACAoB,GAAA,CACA,IAAAC,GAAA,GAAAvP,KAMA,OALAvC,GAAA+R,SACA7N,EAAA8N,KAAA,2BAAAF,EAAAG,eAIAC,IAAAb,KACA,SAAA/K,GACA,GAAAtG,EAAA+R,QAAA,CACA,GAAAI,GAAA,GAAA5P,MACA6P,EAAA1Q,OAAAyQ,EAAAL,GAAA,GACA5N,GAAA8N,KAAA,0BAAAI,EAAA,aAIA,MADAP,IAAA,EACAvL,GAGA,SAAA+L,GAKA,MAJAnO,GAAA8B,MAAA,6BACAyK,GAAA,EACAM,EAAA9M,EAAAqO,MAAA,GACAT,GAAA,EACA5N,EAAAgC,OAAAoM,KAiBA,QAAAH,KACA,GAGAP,GACAY,EAJAC,EAAAvO,EAAA6B,QACA2M,KACAC,IAIAH,GAAAC,EAAAtM,OACA,QAAA8K,GAAA,EAAqCA,EAAAS,EAAA5Q,OAA2CmQ,IAChFW,EAAAF,EAAAT,GACAuB,IAAAlB,KAAAM,EAAAnB,QACAiC,EAAApM,KAAAsL,EAAAlM,UACAiN,EAAArM,KAAAkM,GACAZ,EAAAlB,aAAA,EACAkB,EAAAlM,SAAA,IAsBA,OAlBAxB,GAAAsN,IAAAmB,GAAArB,KACA,SAAAsB,GACA,OAAAC,GAAA,EAA0CA,EAAAH,EAAA5R,OAAoC+R,IAC9EH,EAAAG,IACAH,EAAAG,GAAA/L,QAAA8L,EAAAC,KAIA,SAAAP,GACA,OAAAO,GAAA,EAA0CA,EAAAH,EAAA5R,OAAoC+R,IAC9EH,EAAAG,IACAH,EAAAG,GAAA3M,OAAAoM,KAKAZ,KACAe,EAAA3L,UACA0L,EAjRA,GAAA/S,GAAAiD,KACAgO,GAAA,EACAoB,GAAA,EACAd,EAAA9M,EAAAqO,MAAA,GAEAb,KACAlB,KACAvQ,GACA+R,SAAA,EACA5B,cAAA,KA2QA,OArQA3Q,GAAAuQ,iBACAvQ,EAAAsR,iBACAtR,EAAAoS,sBAmQApS,QRy4BM,SAAUT,EAAQD,IShqCxB,WACAC,EAAAD,SAAA,oBAAA+T,GAIAA,EAAAC,UAAA,+CAAAC,EAAAC,EAAA9O,GAMA,GAAA+O,GAAA,EAOAC,EAAA,EAEAjP,EAAA8O,EAMAI,EAAAlP,EAAA6B,KA6BA,OA3BA7B,GAAA6B,MAAA,WACA,GAAAA,GAAAqN,GAOA,OANAF,KAEAnN,EAAAI,QAAAkN,QAAA,WACAH,MAGAnN,GAGA7B,EAAA8D,4BAAA,WACAmL,KAGAjP,EAAA+D,4BAAA,WACAkL,KAGAjP,EAAAoP,6BAAA,WACA,MAAAH,IAGAjP,EAAAqP,oBAAA,WACA,MAAAL,IAGAhP","file":"adminService.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t(function() {\r\n\t    'use strict';\r\n\t    __webpack_require__(2);\r\n\t    module.exports = angular.module('docGen.adminServices', [])\r\n\t        .provider('i18nService', __webpack_require__(4))\r\n\t        .provider('RemoteService', __webpack_require__(5))\r\n\t        .service('UtilService', __webpack_require__(6))\r\n\t        .service('ActionQueueService', __webpack_require__(7))\r\n\t        .config(__webpack_require__(8));\r\n\t})();\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (__webpack_require__(3))(2);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = vendor_lib;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t(function() {\r\n\t\tmodule.exports = [function() {\r\n\t\t\t\r\n\t\t\tvar provider = this;\r\n\t\t\t//Set defaults\r\n\t\t\tvar i18nData = {\r\n\t\t\t\t'CustomLabel': {},\r\n\t\t\t\t'CustomField': {},\r\n\t\t\t\t'dateFormat': 'MM/DD/YYYY',\r\n\t\t\t\t'dateTemplate': '12/31/1999',\r\n\t\t\t\t'currencyTemplate': '$1,234.00',\r\n\t\t\t\t'quantityTemplate': '1,234.00',\r\n\t\t\t\t'precision': {\r\n\t\t\t\t\t'currency': 2,\r\n\t\t\t\t\t'quantity': 2\r\n\t\t\t\t},\r\n\t\t\t\t'locale': 'en_US'\r\n\t\t\t};\r\n\t\r\n\t\t\tthis.$get = function() {\r\n\t\t\t\treturn new i18nService(i18nData);\r\n\t\r\n\t\t\t};\r\n\t\t\tprovider.setCustomLabel = function(newLabels) {\r\n\t\t\t\tangular.extend(i18nData.CustomLabel, newLabels);\r\n\t\t\t};\r\n\t\t\tprovider.setCustomField = function(newFields) {\r\n\t\t\t\tangular.extend(i18nData.CustomField, newFields);\r\n\t\t\t};\r\n\t\t\tprovider.setDateFormat = function(newFormat) {\r\n\t\t\t\tif (newFormat) {\r\n\t\t\t\t\ti18nData.dateFormat = newFormat;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tprovider.setLocale = function(newLocale) {\r\n\t\t\t\tif (newLocale) {\r\n\t\t\t\t\ti18nData.locale = newLocale;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tprovider.setPrecision = function(key, value) {\r\n\t\t\t\tif (typeof key === 'string' && angular.isDefined(value)) {\r\n\t\t\t\t\ti18nData.precision[key] = Number(value);\r\n\t\r\n\t\t\t\t} else if (typeof key === 'object') {\r\n\t\t\t\t\tangular.extend(i18nData.precision, key);\r\n\t\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tprovider.setDateTemplate = function(newTemplate) {\r\n\t\t\t\tif (newTemplate) {\r\n\t\t\t\t\ti18nData.dateTemplate = newTemplate;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tprovider.setCurrencyTemplate = function(newTemplate) {\r\n\t\t\t\tif (newTemplate) {\r\n\t\t\t\t\ti18nData.currencyTemplate = newTemplate;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tprovider.setQuantityTemplate = function(newTemplate) {\r\n\t\t\t\tif (newTemplate) {\r\n\t\t\t\t\ti18nData.quantityTemplate = newTemplate;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\tfunction i18nService(i18nData) {\r\n\t\t\t\tvar service = i18nData;\r\n\t\t\t\tservice.currencySettings = buildNumberSettings(i18nData.currencyTemplate, i18nData.precision.currency);\r\n\t\t\t\tservice.quantitySettings = buildNumberSettings(i18nData.quantityTemplate, i18nData.precision.quantity);\r\n\t\t\t\tservice.dateSettings = buildDateSettings(i18nData.dateTemplate);\r\n\t\t\t\tservice.timeZoneOffset = (new Date()).getTimezoneOffset() * 60 * 1000;\r\n\t\t\t\treturn service;\r\n\t\r\n\t\t\t\tfunction buildNumberSettings(template, precision) {\r\n\t\t\t\t\tvar settings = {\r\n\t\t\t\t\t\tsymbol: '',\r\n\t\t\t\t\t\tisSymbolBefore: true,\r\n\t\t\t\t\t\tseparator: ',',\r\n\t\t\t\t\t\tgroupLength: 3,\r\n\t\t\t\t\t\tdecimal: '.',\r\n\t\t\t\t\t\tprecision: angular.isNumber(precision) ? precision : 2,\r\n\t\t\t\t\t\tgroupingExp: undefined\r\n\t\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Regex for capturing groups of number separators\r\n\t\t\t\t\t * Matched groups: \r\n\t\t\t\t\t *      0      ignore     1          2        3        4       5     ignore     6    \t\t\t \t\t\t\r\n\t\t\t\t\t * [Symbol(s)][spaces][digit(s)][separator][digits][decimal][digits][spaces][Symbol(s)]\r\n\t\t\t\t\t */\r\n\t\t\t\t\tvar templateRegex = /^(\\D*)(?:\\s*)([\\d\\.\\,\\'\\s\\-]+)([\\.\\,\\'\\s\\-])(\\d{3,4})(\\.|\\,)(\\d{2,})(?:\\s*)(\\D*)$/;\r\n\t\t\t\t\tvar matches = template.match(templateRegex);\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t//Discard first element -- the full string match\r\n\t\t\t\t\t\tmatches.shift();\r\n\t\t\t\t\t\t//Check symbol and where it was matched\r\n\t\t\t\t\t\tif (matches[0]) {\r\n\t\t\t\t\t\t\tsettings.symbol = matches[0];\r\n\t\t\t\t\t\t\tsettings.isSymbolBefore = true;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tsettings.symbol = matches[6];\r\n\t\t\t\t\t\t\tsettings.isSymbolBefore = false;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//Get the rest of the matches\r\n\t\t\t\t\t\tsettings.separator = matches[2];\r\n\t\t\t\t\t\tsettings.groupLength = matches[3].length;\r\n\t\t\t\t\t\tsettings.decimal = matches[4];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Compile the grouping regexp for fast reuse\r\n\t\t\t\t\t * Matching groups: \r\n\t\t\t\t\t *        0               1         ignored         2\r\n\t\t\t\t\t * [leading digits][grouped digits][decimal][fraction digits]\r\n\t\t\t\t\t */\r\n\t\t\t\t\tvar regexpStr = '^(\\\\d{1,' + settings.groupLength + '})?' + '((?:\\\\d{' + settings.groupLength + '})*)' + '(?:[\\.\\,](\\\\d*))?$';\r\n\t\t\t\t\tsettings.groupingExp = new RegExp(regexpStr);\r\n\t\t\t\t\treturn settings;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t/**\r\n\t\t\t\t * Construct settings required for date rendering. May turn this into\r\n\t\t\t\t * \ta way of making salesforce date format compatible with the 'moment'\r\n\t\t\t\t * \tlibrary so that the date filter can take advantage of moment.\r\n\t\t\t\t * \t \r\n\t\t\t\t */\r\n\t\t\t\tfunction buildDateSettings(dateTemplate) {\r\n\t\t\t\t\tvar settings = {\r\n\t\t\t\t\t\tseparator: '/',\r\n\t\t\t\t\t\tordering: ['mm', 'dd', 'yyyy'],\r\n\t\t\t\t\t\tgroupingExp: undefined\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Regex for capturing date digits\r\n\t\t\t\t\t * Matched groups: \r\n\t\t\t\t\t *      0           1         2           ignore          3\r\n\t\t\t\t\t * [1-4 digits][separator][1|2 digits][same separator][2-4 digits]\r\n\t\t\t\t\t */\r\n\t\t\t\t\tvar templateRegex = /(\\d{1,4})([\\/\\s\\-\\.])(\\d{1,2})(?:\\2)(\\d{1,4})/;\r\n\t\t\t\t\tvar matches = dateTemplate.match(templateRegex);\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t//Discard first element -- the full string match\r\n\t\t\t\t\t\tmatches.shift();\r\n\t\t\t\t\t\tsettings.separator = matches[1] || '/';\r\n\t\t\t\t\t\t[0, 2, 3].forEach(function(matchIndex, loopIndex) {\r\n\t\t\t\t\t\t\tvar digits = matches[matchIndex];\r\n\t\t\t\t\t\t\tvar component = '';\r\n\t\t\t\t\t\t\tvar str = '';\r\n\t\t\t\t\t\t\tvar numVal = Number(digits);\r\n\t\t\t\t\t\t\tif (numVal <= 12) {\r\n\t\t\t\t\t\t\t\tcomponent = 'm';\r\n\t\r\n\t\t\t\t\t\t\t} else if (numVal <= 31) {\r\n\t\t\t\t\t\t\t\tcomponent = 'd';\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcomponent = 'y';\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// TODO : .repeat method is part of ES6 and not compatible with IE and safari \r\n\t\t\t\t\t\t\t// settings.ordering[loopIndex] = component.repeat(digits.length);\r\n\t\r\n\t\t\t\t\t\t\t// put the simple logic instead of .repeat method to fix the issue\r\n\t\t\t\t\t\t\tfor (var i = 0; i < digits.length; i++) {\r\n\t\t\t\t\t\t\t\tstr += component;\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tsettings.ordering[loopIndex] = str;\r\n\t\r\n\t\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Compile the grouping regexp for fast reuse\r\n\t\t\t\t\t * Matching groups: \r\n\t\t\t\t\t *    ignored     0       ignored    1       ignored    2       ignored\r\n\t\t\t\t\t * [whitespace][digits][separator][digits][separator][digits][whitespace]\r\n\t\t\t\t\t */\r\n\t\t\t\t\tvar paddingExp = '\\\\s*';\r\n\t\t\t\t\tvar separatorExp = paddingExp + '\\\\' + settings.separator + '?' + paddingExp;\r\n\t\t\t\t\tvar regexpStr = ['^', paddingExp, '(\\\\d{1,4})', separatorExp, '(\\\\d{1,4})?', separatorExp, '(\\\\d{1,4})?', paddingExp, '$'].join('');\r\n\t\t\t\t\tsettings.groupingExp = new RegExp(regexpStr);\r\n\t\t\t\t\treturn settings;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\t}];\r\n\t\r\n\t\r\n\t})();\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t(function() {\r\n\t    module.exports = [function() {\r\n\t\r\n\t        var provider = this;\r\n\t        var actionsMap = {};\r\n\t        var redirectOnFail = '/';\r\n\t        var trackAllRemoteCalls = false;\r\n\t\r\n\t        provider.setRemoteActions = function(newActions) {\r\n\t            \r\n\t            angular.extend(actionsMap, newActions);\r\n\t            return provider;\r\n\t        };\r\n\t\r\n\t        provider.setRedirectLocation = function(newLocation) {\r\n\t            redirectOnFail = newLocation ? newLocation : false;\r\n\t            return provider;\r\n\t        };\r\n\t\r\n\t        provider.setTrackAllRemoteCalls = function(isEnabled) {\r\n\t            trackAllRemoteCalls = isEnabled;\r\n\t            return provider;\r\n\t        };\r\n\t\r\n\t        function RemoteServiceFactory($q, $log, $window) {\r\n\t            return new RemoteService($q, $log, $window, actionsMap, redirectOnFail);\r\n\t\r\n\t        }\r\n\t\r\n\t        RemoteServiceFactory.$inject = ['$q', '$log', '$window'];\r\n\t        \r\n\t        this.$get = RemoteServiceFactory;\r\n\t\r\n\t        function RemoteService($q, $log, $window, RemoteActions, redirectOnFail) {\r\n\t            var service = {};\r\n\t            var lastTransaction = {};\r\n\t            initRemoteActionFunctions();\r\n\t            return service;\r\n\t\r\n\t            function initRemoteActionFunctions() {\r\n\t                var actionKey, actionName, isProp, isStr;\r\n\t                for (actionKey in RemoteActions) {\r\n\t                    isProp = RemoteActions.hasOwnProperty(actionKey);\r\n\t                    isStr = typeof actionKey === 'string';\r\n\t                    if (isProp && isStr) {\r\n\t                        actionConfig = getRemoteActionConfig(actionKey);\r\n\t                        service[actionKey] = createRemoteActionFunction(actionConfig);\r\n\t\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            /*\r\n\t             * This method will check RemoteAction[key] contains action string or action config object\r\n\t             * according to that it will create actionConfig object and returns it \r\n\t             */\r\n\t            function getRemoteActionConfig(actionKey) {\r\n\t                var config = {};\r\n\t\r\n\t                if (angular.isDefined(RemoteActions[actionKey])) {\r\n\t                    var actionConf = RemoteActions[actionKey];\r\n\t                    if (angular.isString(actionConf)) {\r\n\t                        config.actionName = actionConf;\r\n\t                        config.skipLoader = false;\r\n\t\r\n\t                    } else if (angular.isObject(actionConf)) {\r\n\t                        config.actionName = (angular.isDefined(actionConf.actionName)) ? actionConf.actionName : null;\r\n\t                        config.skipLoader = (angular.isDefined(actionConf.skipLoader)) ? actionConf.skipLoader : false;\r\n\t\r\n\t                    }\r\n\t\r\n\t                }\r\n\t                return config;\r\n\t            }\r\n\t\r\n\t            /**\r\n\t             * Used for generating methods that can be called on the service by the name\r\n\t             * \tdeclared in the RemoteActions object.\r\n\t             * Each method passes its fully-qualified name and its\r\n\t             * \targuments to invokeRemoteAction. The arguments passed\r\n\t             * \tto this function should just match the signature of \r\n\t             * \tthe Apex method. \r\n\t             * @return {promise} resolves with the result of the remote action\r\n\t             */\r\n\t            function createRemoteActionFunction(actionConfig) {\r\n\t                var actionFunction = function() {\r\n\t                    return invokeRemoteAction(actionConfig, arguments);\r\n\t\r\n\t                };\r\n\t                return actionFunction;\r\n\t\r\n\t            }\r\n\t            /**\r\n\t             * Helper for calling visualforce remoting. \r\n\t             *  \r\n\t             * @param \t{string}\tactionName \tthe remote action to invoke\r\n\t             * @param \t{array}\t\tactionParams\tany number of parameters to pass to remote\r\n\t             *          \t\t\t\t\t\t\t\t\t\t\t\taction before callback \r\n\t             * @return {promise} a $q promise that resolves with result of remote action\r\n\t             *\r\n\t             * Example: \r\n\t             * \t\t<code>\r\n\t             * \t\tvar thenable = invokeRemoteAction(RemoteActions.getCartLineItems, [cartRequest]);\r\n\t             * \t\tthenable.then(function (result) {\r\n\t             * \t\t\tuseResult(result);\r\n\t             * \t\t});\r\n\t             * \t\t</code>\r\n\t             * Here, thenable will be a promise that gets resolved with the result of the remote action \r\n\t             */\r\n\t            function invokeRemoteAction(actionConfig, actionParams) {\r\n\t                // $log.debug('invokeRemoteAction-->'+actionConfig.actionName, actionParams);\r\n\t                \r\n\t                //Constuct deferred object for return\r\n\t                var deferred, errorMessage, remoteActionWithParams, resolver, remotingParams, actionName;\r\n\t                deferred = $q.defer();\r\n\t                actionName = actionConfig.actionName;\r\n\t\r\n\t                setRemoteServiceCount(actionConfig, true);\r\n\t\r\n\t                if (!actionName || typeof actionName !== 'string') {\r\n\t                    errorMessage = \"Error - Could not invoke remote action: action name invalid!\";\r\n\t                    $log.error(errorMessage);\r\n\t                    deferred.reject(errorMessage);\r\n\t                    return deferred.promise;\r\n\t\r\n\t                }\r\n\t                //Construct list with aciton name and parameters to pass to invokeAction\r\n\t                remoteActionWithParams = [actionName];\r\n\t                for (var argIndex = 0, nextArg; argIndex < actionParams.length; argIndex++) {\r\n\t                    nextArg = actionParams[argIndex];\r\n\t                    /*if (!nextArg) {\r\n\t                        errorMessage = \"Error - Could not construct remote action parameters. Parameter #\" + argIndex + \" is undefined!\";\r\n\t                        $log.error(errorMessage);\r\n\t                        deferred.reject(errorMessage);\r\n\t                        return deferred.promise;\r\n\t\r\n\t                    }*/\r\n\t                    remoteActionWithParams.push(nextArg);\r\n\t\r\n\t                }\r\n\t                //Add the resolve function and remoting params to argument array\r\n\t                resolver = function resolveRemoteAction(result, event) {\r\n\t                    if (event.status) {\r\n\t                        if(result !== null) {\r\n\t\t                        $log.debug('Resolved \"' + actionName + '\"' +\r\n\t\t                                   ', Time taken: ' + result.timeTaken / 1000 + ' sec.' +\r\n\t\t                                   ', Query count: ' + result.queryCount);\r\n\t\r\n\t\t                        if (result.timeDetail) {\r\n\t\t\t                        $log.debug('Timings for ' + actionName, result.timeDetail);\r\n\t\t                        }\r\n\t                        }\r\n\t\r\n\t                        deferred.resolve(result);\r\n\t\r\n\t                    } else {\r\n\t                        errorMessage = 'Error - Could not resolve remote action: ' + actionName;\r\n\t                        $log.error(errorMessage, actionParams, event.message);\r\n\t                        //Currently the only way to check whether request failed due to user logout\r\n\t                        var isLoggedOut = event.message.toLowerCase().indexOf('logged') >= 0;\r\n\t                        if (isLoggedOut && redirectOnFail) {\r\n\t                            $window.location.href = redirectOnFail;\r\n\t\r\n\t                        }\r\n\t                        deferred.reject(event);\r\n\t\r\n\t                    }\r\n\t\r\n\t                    setRemoteServiceCount(actionConfig, false);\r\n\t                };\r\n\t                remoteActionWithParams.push(resolver);\r\n\t\r\n\t                //Add the default parameters for remoting call\r\n\t                remotingParams = {\r\n\t                    \"buffer\": false,\r\n\t                    \"escape\": false,\r\n\t                    \"timeout\": 120000\r\n\t                };\r\n\t                remoteActionWithParams.push(remotingParams);\r\n\t\r\n\t                //Try to call visualforce remoting invokeAction with the parameters we built \r\n\t                try {\r\n\t                    Visualforce.remoting.Manager.invokeAction.apply(Visualforce.remoting.Manager, remoteActionWithParams);\r\n\t\r\n\t                } catch (ex) {\r\n\t                    errorMessage = 'Error - Could not invoke remote action: ' + actionName;\r\n\t                    $log.error(errorMessage, actionParams, ex);\r\n\t                    deferred.reject(errorMessage);\r\n\t\r\n\t                }\r\n\t                return deferred.promise;\r\n\t\r\n\t            }\r\n\t\r\n\t            /*\r\n\t             * This method sets pendingRemoteServiceCount of $q service (decorrated in queueWrapperService.js) \r\n\t             * based on actionConfig.skip and LoggerLevel\r\n\t             */\r\n\t            function setRemoteServiceCount(actionConfig, incrementFlag) {\r\n\t                //$log.debug('setRemoteServiceCount-->', actionConfig, incrementFlag);\r\n\t                if (!actionConfig.skipLoader || trackAllRemoteCalls) {\r\n\t                    if (incrementFlag) {\r\n\t                        $q.incrementRemoteServiceCount();\r\n\t\r\n\t                    } else {\r\n\t                        $q.decrementRemoteServiceCount();\r\n\t\r\n\t                    }\r\n\t\r\n\t                }\r\n\t            }\r\n\t\r\n\t        }\r\n\t\r\n\t    }];\r\n\t\r\n\t})();\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t(function() {\r\n\t    module.exports = ['lodash', function(_) {\r\n\t        var service = this;\r\n\t\r\n\t        service.frequencyConstants = {\r\n\t            FREQUENCY_HOURLY: 'Hourly',\r\n\t            FREQUENCY_DAILY: 'Daily',\r\n\t            FREQUENCY_WEEKLY: 'Weekly',\r\n\t            FREQUENCY_MONTHLY: 'Monthly',\r\n\t            FREQUENCY_QUARTERLY: 'Quarterly',\r\n\t            FREQUENCY_HALFYEARLY: 'Half Yearly',\r\n\t            FREQUENCY_YEARLY: 'Yearly'\r\n\t        };\r\n\t\r\n\t        service.priceTypesConstants = {\r\n\t            PRICETYPE_ONETIME: 'One Time',\r\n\t            PRICETYPE_RECURRING: 'Recurring',\r\n\t            PRICETYPE_USAGE: 'Usage',\r\n\t            PRICETYPE_INCLUDED_USAGE: 'Included Usage'\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * Use string-to-number conversion to compensate for floating point \r\n\t         * \terrors in standard javascript rounding.\r\n\t         * @param  {Number/String} value\r\n\t         * @param  {Number/String} precision \tthese can be numbers or strings\r\n\t         *                                    representing numbers\r\n\t         * @return {Number}\tRounded value\r\n\t         */\r\n\t        service.round = function(value, precision) {\r\n\t            precision = precision ? precision : 0;\r\n\t            var roundExpPos = \"e+\" + precision;\r\n\t            var roundExpNeg = \"e-\" + precision;\r\n\t            return Number(Math.round(value + roundExpPos) + roundExpNeg);\r\n\t\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * Check whether a nmber is within a min/max range. If min or max is not\r\n\t         * \tof type number, it the value is assumed to automatically meet the \r\n\t         * \tcriteria. If the value to check is not a number type, it automatically\r\n\t         * \tfails.\r\n\t         * @param  {Number}  minVal    \r\n\t         * @param  {Number}  maxVal    \r\n\t         * @param  {Number}  betweenVal\r\n\t         * @param  {Boolean}  strictly\t\tWhether to compare strictly. False by default.\r\n\t         * @return {Boolean}           \r\n\t         */\r\n\t        service.isBetween = function(minVal, maxVal, betweenVal, strictly) {\r\n\t            if (!angular.isNumber(betweenVal)) {\r\n\t                return false;\r\n\t\r\n\t            }\r\n\t            var minSatisfied, maxSatisfied;\r\n\t            if (!strictly) {\r\n\t                minSatisfied = angular.isNumber(minVal) ? betweenVal >= minVal : true;\r\n\t                maxSatisfied = angular.isNumber(maxVal) ? betweenVal <= maxVal : true;\r\n\t\r\n\t            } else {\r\n\t                minSatisfied = angular.isNumber(minVal) ? betweenVal > minVal : true;\r\n\t                maxSatisfied = angular.isNumber(maxVal) ? betweenVal < maxVal : true;\r\n\t\r\n\t            }\r\n\t            return minSatisfied && maxSatisfied;\r\n\t\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * Replicate Java string format where you can pass an string that has\r\n\t         * \tgroups such as {0}, {1}, ... and an array of strings to insert at\r\n\t         * \tthe appropriate indicies. Used for filling in custom labels.\r\n\t         * @param  {[type]} baseString [description]\r\n\t         * @param  {[type]} inserts    [description]\r\n\t         * @return {[type]}            [description]\r\n\t         */\r\n\t        service.stringFormat = function(baseString, inserts) {\r\n\t            if (!baseString) {\r\n\t                return '';\r\n\t\r\n\t            }\r\n\t            if (!angular.isArray(inserts)) {\r\n\t                return baseString;\r\n\t\r\n\t            }\r\n\t            var stringGroups = baseString.split(/\\{(\\d+)\\}/),\r\n\t                formattedString = '',\r\n\t                isInsert = false,\r\n\t                insertIndex = 0,\r\n\t                nextInsert = '';\r\n\t            for (var stringIndex = 0; stringIndex < stringGroups.length; stringIndex++) {\r\n\t                if (isInsert) {\r\n\t                    isInsert = false;\r\n\t                    insertIndex = parseInt(stringGroups[stringIndex]);\r\n\t                    nextInsert = insertIndex < inserts.length ? inserts[insertIndex] : '';\r\n\t                    formattedString += nextInsert;\r\n\t\r\n\t                } else {\r\n\t                    isInsert = true;\r\n\t                    formattedString += stringGroups[stringIndex];\r\n\t\r\n\t                }\r\n\t\r\n\t            }\r\n\t            return formattedString;\r\n\t\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * returns true when the parameter passed is undefined or null or empty array or blank string\r\n\t         * @param obj any kind of parameter \r\n\t         */\r\n\t        service.isEmpty = function(obj) {\r\n\t            if (angular.isDefined(obj) && obj !== null) {\r\n\t                if (angular.isArray(obj) && obj.length === 0 || obj === '') {\r\n\t                    return true;\r\n\t\r\n\t                }\r\n\t                return false;\r\n\t\r\n\t            }\r\n\t            return true;\r\n\t\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * Construct a date object in which the time is set to 12:00 AM GMT.\r\n\t         * This is used to match salesforce UTC milliseconds standard for dates.\r\n\t         * \r\n\t         * @param  {Number} year  year as numerical value\r\n\t         * @param  {Number} month month value, where January = 0\r\n\t         * @param  {Number} date  date as numerical value\r\n\t         * @return {Date}\r\n\t         */\r\n\t        service.newUTCDate = function(year, month, date) {\r\n\t            var newDate = new Date();\r\n\t            newDate.setUTCHours(0, 0, 0);\r\n\t            if (angular.isNumber(year)) {\r\n\t                newDate.setUTCFullYear(year);\r\n\t\r\n\t            }\r\n\t            if (angular.isNumber(month)) {\r\n\t                newDate.setUTCMonth(month);\r\n\t\r\n\t            }\r\n\t            if (angular.isNumber(date)) {\r\n\t                newDate.setUTCDate(date);\r\n\t\r\n\t            }\r\n\t            return newDate;\r\n\t\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * Computes the new date for adding days to the given date \r\n\t         * @param date current date\r\n\t         * @param days number of days to add\r\n\t         * @return the new date\r\n\t         */\r\n\t        service.addDays = function(date, days) {\r\n\t            return date + 86400000 * days;\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * Computes the end date for the given start date and term parameters\r\n\t         * @param startDate the term start date\r\n\t         * @param term the term \r\n\t         * @param frequency the frequency associated with the term\r\n\t         * @return the end date\r\n\t         */\r\n\t        service.computeEndDate = function(startDate, term, frequency) {\r\n\t            var newEndDate = new Date(startDate);\r\n\t\r\n\t            if (frequency === service.frequencyConstants.FREQUENCY_HOURLY) {\r\n\t                // hourly\r\n\t                newEndDate = newEndDate.setDate(newEndDate.getDate() + (1 / 24 * term));\r\n\t\r\n\t            } else if (frequency === service.frequencyConstants.FREQUENCY_DAILY) {\r\n\t                // daily\r\n\t                newEndDate = newEndDate.setDate(newEndDate.getDate() + term);\r\n\t\r\n\t            } else if (frequency === service.frequencyConstants.FREQUENCY_WEEKLY) {\r\n\t                // weekly\r\n\t                newEndDate = newEndDate.setDate(newEndDate.getDate() + (term * 7));\r\n\t\r\n\t            } else if (frequency === service.frequencyConstants.FREQUENCY_MONTHLY) {\r\n\t                // monthly\r\n\t                newEndDate = service.computeEndDateByMonths(startDate, term, 1);\r\n\t\r\n\t            } else if (frequency === service.frequencyConstants.FREQUENCY_QUARTERLY) {\r\n\t                // quarterly\r\n\t                newEndDate = service.computeEndDateByMonths(startDate, term, 3);\r\n\t\r\n\t            } else if (frequency === service.frequencyConstants.FREQUENCY_HALFYEARLY) {\r\n\t                // half yearly\r\n\t                newEndDate = service.computeEndDateByMonths(startDate, term, 6);\r\n\t\r\n\t            } else if (frequency === service.frequencyConstants.FREQUENCY_YEARLY) {\r\n\t                // yearly\r\n\t                newEndDate = service.computeEndDateByMonths(startDate, term, 12);\r\n\t\r\n\t            } else {\r\n\t                //Added for app to not break as start date from ms is converted to date object\r\n\t                newEndDate = startDate;\r\n\t            }\r\n\t\r\n\t            return newEndDate;\r\n\t\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * compute end date for monthly, quartely, half-yearly or yearly term \r\n\t         * @param startDate line item start date\r\n\t         * @param term number of months plus extra days / 30 \r\n\t         * @param frequencyInMonths 1-monthly, 3-quarterly 6-half-yearly 12-yearly \r\n\t         */\r\n\t        service.computeEndDateByMonths = function(startDate, term, frequencyInMonths) {\r\n\t            var months = (term * frequencyInMonths);\r\n\t\r\n\t            var newEndDate = new Date(startDate);\r\n\t            newEndDate = newEndDate.setMonth(newEndDate.getMonth() + months);\r\n\t\r\n\t            var dateToFindDays = new Date(newEndDate);\r\n\t            dateToFindDays = dateToFindDays.setDate(dateToFindDays.getDate() + 1);\r\n\t\r\n\t            var daysInMonths = service.daysInMonth(new Date(dateToFindDays).getFullYear(), new Date(dateToFindDays).getMonth());\r\n\t            var remainingTerms = ((term * frequencyInMonths) - months);\r\n\t            var extraDays = Math.round(remainingTerms * daysInMonths);\r\n\t\r\n\t            newEndDate = new Date(newEndDate);\r\n\t            newEndDate = newEndDate.setDate(newEndDate.getDate() + (extraDays - 1));\r\n\t\r\n\t            return newEndDate;\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * reorder elements within an array such that when a matching key is found, the element is moved to the \r\n\t         * head of that array - this check is repeated for every element of the array.\r\n\t         * @param - source array\r\n\t         * @param - predicate, callback function; Must return true if element should move to the head of the array\r\n\t         */\r\n\t        service.reorderArray = function(array, callback) {\r\n\t            if (_.isArray(array) === false || array.length === 0 || _.isFunction(callback) === false) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var spliceIdx = [];\r\n\t\r\n\t            for (var i = 0; i < array.length; i++) {\r\n\t                // callback should return true/false\r\n\t                if ((i > 1) && callback(array[i])) {\r\n\t                    spliceIdx.push(i);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            spliceIdx.forEach(function(idx) {\r\n\t                var culled = array.splice(idx, 1);\r\n\t                array.splice(0, 0, culled[0]);\r\n\t            });\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * compute days in given year and a month\r\n\t         * @param year\r\n\t         * @param month\r\n\t         * return days in month\r\n\t         */\r\n\t        service.daysInMonth = function(year, month) {\r\n\t            return new Date(year, month, 0).getDate();\r\n\t        };\r\n\t\r\n\t        service.removeTempUIAttributes = function(obj) {\r\n\t            Object.keys(obj).forEach(function(key) {\r\n\t                if (_.startsWith(key, '@@') || _.startsWith(key, '$$')) {\r\n\t                    delete obj[key];\r\n\t                } else if (angular.isObject(obj[key])) {\r\n\t                    service.removeTempUIAttributes(obj[key]);\r\n\t                }\r\n\t            });\r\n\t        };\r\n\t\r\n\t        service.validateEndDate = function(date) {\r\n\t            var now = new Date();\r\n\t            if (now.getTime() > date) {\r\n\t                return false;\r\n\t            }\r\n\t            return true;\r\n\t        };\r\n\t\r\n\t        service.validateDate = function(date) {\r\n\t            var date_regex = /^(0[1-9]|1[0-2])\\/(0[1-9]|1\\d|2\\d|3[01])\\/(19|20)\\d{2}$/; //Validates the format (MM/DD/YYYY), with a year between 1900 and 2099\r\n\t            if (angular.isUndefined(date) || date === null) {\r\n\t                return false;\r\n\t            } else if (date.toString().trim().length < 1) {\r\n\t                return false;\r\n\t            } else if (date_regex.test(date)) {\r\n\t                return false;\r\n\t            }\r\n\t            return true;\r\n\t        };\r\n\t\r\n\t        service.uniq = function(inputArray) {\r\n\t            var tempArray = [];\r\n\t            var tempObj = {};\r\n\t            _.forEach(inputArray, function(value, key) {\r\n\t                if (!tempObj[value.id]) {\r\n\t                    tempArray.push(value);\r\n\t                    tempObj[value.id] = value.id;\r\n\t                }\r\n\t            });\r\n\t            return tempArray;\r\n\t        };\r\n\t\r\n\t        service.intersection = function(inputArray) {\r\n\t            var tempArray = [];\r\n\t            _.forEach(inputArray, function(value, key) {\r\n\t                tempArray.push(value.actionArr);\r\n\t            });\r\n\t            return _.intersection.apply(_, tempArray);\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * Get the object corresponding to field name\r\n\t         * @param contextSO the \"starting\" sObject\r\n\t         * @param fieldAPIName the fully qualified field API name\r\n\t         * @return the object specified by fieldName\r\n\t         */\r\n\t        service.sObjectFromField = function(contextSO, fieldAPIName) {\r\n\t            //set new value\r\n\t            var path = fieldAPIName.split('.');\r\n\t            var curObject = contextSO;\r\n\t            for (var i = 0, max = path.length - 1; i < max; i++) {\r\n\t                if (typeof(curObject) !== 'undefined' && curObject !== null) {\r\n\t                    curObject = curObject[path[i]];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return curObject;\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * create popup for Product Information list\r\n\t         * @param product Object\r\n\t         */\r\n\t        service.createPopup = function(product) {\r\n\t            var infoURL = \"\";\r\n\t            if (product.productInformationList.length > 0) {\r\n\t                if (product.productInformationList[0].InformationType__c == \"Attached File\") {\r\n\t                    infoURL = \"/servlet/servlet.FileDownload?file=\" + product.productInformationList[0].FileId__c;\r\n\t\r\n\t                } else if (product.productInformationList[0].InformationType__c == \"Embedded Code\") {\r\n\t                    infoURL = product.productInformationList[0].EmbedCode__c;\r\n\t\r\n\t                } else if (product.productInformationList[0].InformationType__c == \"URL Address\") {\r\n\t                    infoURL = product.productInformationList[0].ContentUrl__c;\r\n\t\r\n\t                }\r\n\t            } else {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var header = product.productInformationList.length > 0 ? product.productInformationList[0].Name : \"\";\r\n\t            var isEmbed = product.productInformationList[0].InformationType__c == \"Embedded Code\" ? true : false;\r\n\t\r\n\t            if (infoURL === \"\" || infoURL === null) {\r\n\t                return false;\r\n\t            }\r\n\t\r\n\t            var url = isEmbed ? '' : infoURL;\r\n\t\r\n\t            var infoModal = window.open(url, 'Product Information', 'menubar=1,resizable=1,width=712,height=500');\r\n\t            if (isEmbed) {\r\n\t                infoModal.document.write('<html><head><title>Product Information</title></head>');\r\n\t                infoModal.document.write('<body><center><h3>' + header + '</h3>');\r\n\t                infoModal.document.write(infoURL);\r\n\t                infoModal.document.write('</center></body></html>');\r\n\t            }\r\n\t            if (window.focus) {\r\n\t                infoModal.focus();\r\n\t            }\r\n\t        };\r\n\t\r\n\t        return service;\r\n\t\r\n\t    }];\r\n\t})();\r\n\t\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t(function() {\r\n\t    module.exports = ['$q', '$log', function($q, $log) {\r\n\t\r\n\t        var service = this;\r\n\t        var isScheduled = false;\r\n\t        var processingActions = false;\r\n\t        var tail = $q.when(true);\r\n\t        var actionQueue = [];\r\n\t        var scheduledActionQueue = [];\r\n\t        var hashedActionsMap = {};\r\n\t        var settings = {\r\n\t            logTime: true,\r\n\t            maxPrecedence: 1024\r\n\t        };\r\n\t\r\n\t        /* -- Public methods -- */\r\n\t\r\n\t        //Used to register indiviudal actions and schedule them seperately\r\n\t        service.registerAction = registerAction;\r\n\t        service.scheduleAction = scheduleAction;\r\n\t        service.isProcessingActions = isProcessingActions;\r\n\t\r\n\t        /* -- Method Declarations -- */\r\n\t\r\n\t\r\n\t        /**\r\n\t         * Register a function in the action queue, optionally assignign it a \r\n\t         * \tprecedence in execution and a actionKey with which to hash. If the function\r\n\t         * \tparameter is not valid, does nothing. \r\n\t         *\r\n\t         * @param  {function}\tfunctionObject \tA function that can be executed by the queue.\r\n\t         * @param  {number}\t\tprecedence     \tPrecedence with which to execute function. \r\n\t         *                                   \tHigher = execute sooner\r\n\t         *                                   \tUndefined = Max (first)\r\n\t         * @param  {string} \tactionKey       Key with which to hash the function. If provided,\r\n\t         *                                   \tthe function is to be queued by this key instead\r\n\t         *                                   \tof by passing it as an object. Defaults to funciton.toString\r\n\t         * @return {actionQueue}              Reference to this service to allow chainging.\r\n\t         */\r\n\t        function registerAction(functionObject, precedence, actionKey) {\r\n\t            var hashVal, existed;\r\n\t            var max = settings.maxPrecedence;\r\n\t            if (!(functionObject instanceof Function)) {\r\n\t                return service;\r\n\t\r\n\t            }\r\n\t            //Calculate values\r\n\t            if (!angular.isNumber(precedence)) {\r\n\t                precedence = max;\r\n\t\r\n\t            } else {\r\n\t                precedence = Math.min(precedence, max);\r\n\t\r\n\t            }\r\n\t            hashVal = actionKey ? hashObject(actionKey) : hashObject(functionObject);\r\n\t            //Store information\r\n\t            //existed = hashedActionsMap[hashVal];\r\n\t            hashedActionsMap[hashVal] = {\r\n\t                \"action\": functionObject,\r\n\t                \"precedence\": precedence,\r\n\t                \"isScheduled\": false\r\n\t            };\r\n\t\r\n\t            return service;\r\n\t\r\n\t        }\r\n\t\r\n\t        /**\r\n\t         * Adapted from ActionFunctionQueue; converts any object into a string\r\n\t         * \tthat has a toString method then hashes that string to an integer value.\r\n\t         * \t\r\n\t         * @param  {object} \tobjectToHash\r\n\t         * @return {integer}  hashed integer value\r\n\t         */\r\n\t        function hashObject(objectToHash) {\r\n\t            var str = objectToHash.toString();\r\n\t            var hash = 5381;\r\n\t            for (i = 0; i < str.length; i++) {\r\n\t                char = str.charCodeAt(i);\r\n\t                hash = ((hash << 5) + hash) + char; /* hash * 33 + c */\r\n\t\r\n\t            }\r\n\t            return hash;\r\n\t\r\n\t        }\r\n\t\r\n\t\r\n\t        /**\r\n\t         * Schedule a particular action or array of actions. Actions should be \r\n\t         * \tin scheudled using the same function object or prototype with\r\n\t         * \twhich they were registered. \r\n\t         *\r\n\t         * Note: if parameter is an array, the order of actions does not influence\r\n\t         * \tthe order in which actions will be enqueued. Instead, the registered\r\n\t         * \tprecedence will be respected.\r\n\t         * \t\r\n\t         * @param {String|Function|Array} actionKey  action or collection of actions\r\n\t         * @return {promise} Resolves with the result of the action. Resolve waits until the queue finishes running.\r\n\t         */\r\n\t        function scheduleAction(actionKey) {\r\n\t            if (angular.isUndefined(actionKey) || actionKey === null) {\r\n\t                return tail;\r\n\t\r\n\t            }\r\n\t            var actionArr = [];\r\n\t            if (angular.isArray(actionKey)) {\r\n\t                actionArr = actionKey;\r\n\t\r\n\t            } else {\r\n\t                actionArr.push(actionKey);\r\n\t\r\n\t            }\r\n\t            var actionIndex, nextActionKey, newSchedule;\r\n\t            var resultPromises = [];\r\n\t            for (actionIndex = 0; actionIndex < actionArr.length; actionIndex += 1) {\r\n\t                nextActionKey = actionArr[actionIndex];\r\n\t                queuedResult = queueByPrecedence(nextActionKey);\r\n\t                if (queuedResult) {\r\n\t                    resultPromises.push(queuedResult);\r\n\t                }\r\n\t                if (!isScheduled) {\r\n\t                    isScheduled = true;\r\n\t                    tail = tail.then(fireSync);\r\n\t\r\n\t                }\r\n\t\r\n\t            }\r\n\t            if (resultPromises.length == 1) {\r\n\t                return resultPromises[0];\r\n\t\r\n\t            } else if (resultPromises.length > 1) {\r\n\t                return $q.all(resultPromises);\r\n\t\r\n\t            }\r\n\t            return tail;\r\n\t\r\n\t        }\r\n\t\r\n\t        /**\r\n\t         * Put a particular action's info into the queue.\r\n\t         * @param  {object} actionKey \tKey used to reference object\r\n\t         * @return {Boolean}           \tTrue if action becomes scheduled, else False.\r\n\t         */\r\n\t        function queueByPrecedence(actionKey) {\r\n\t            if (!actionKey) {\r\n\t                return false; //Invalid; do nothing.\r\n\t\r\n\t            }\r\n\t\r\n\t            var hashVal = hashObject(actionKey);\r\n\t            var actionInfo = hashedActionsMap[hashVal];\r\n\t            //Invalid or already scheduled.\r\n\t            if (!actionInfo) {\r\n\t                return false;\r\n\t\r\n\t            } else if (actionInfo.isScheduled) {\r\n\t                return actionInfo.deferred.promise;\r\n\t\r\n\t            }\r\n\t\r\n\t            var actionIndex = scheduledActionQueue.length; //add at the end for the least precendence action\r\n\t            for (var index = 0; index < scheduledActionQueue.length; ++index) {\r\n\t                var nextActionInfo = scheduledActionQueue[index];\r\n\t                if (actionInfo.precedence > nextActionInfo.precedence) {\r\n\t                    actionIndex = index;\r\n\t                    break;\r\n\t\r\n\t                }\r\n\t\r\n\t            }\r\n\t\r\n\t            scheduledActionQueue.splice(actionIndex, 0, actionInfo);\r\n\t            actionInfo.isScheduled = true;\r\n\t            actionInfo.deferred = $q.defer();\r\n\t            return actionInfo.deferred.promise;\r\n\t\r\n\t        }\r\n\t\r\n\t        /**\r\n\t         * Returns true when the action function queue has begun processing actions, false when\r\n\t         * the queue has completed and is idle.\r\n\t         * @return {Boolean} True when actions are processing, false otherwise.\r\n\t         */\r\n\t        function isProcessingActions() {\r\n\t            return processingActions;\r\n\t\r\n\t        }\r\n\t\r\n\t        /**\r\n\t         * Fires a sync event. The new event is chained onto the tail of the\r\n\t         *  previous event, meaning events will run sequentially.\r\n\t         * If the actions in the queue are rejected, i.e. throw errors,\r\n\t         * \tthe tail of schedlued sync is reset, the rejection is returned.\r\n\t         * Optionally logs the information about how long the process took.\r\n\t         * \r\n\t         * @return {Promise} tail of scheduled queue\r\n\t         */\r\n\t        function fireSync() {\r\n\t            isScheduled = false;\r\n\t            processingActions = true;\r\n\t            var sentTime = new Date();\r\n\t            if (settings.logTime) {\r\n\t                $log.info(\"Action Queue Submitted: \" + sentTime.toGMTString());\r\n\t\r\n\t            }\r\n\t            //Build and run queue of actions\r\n\t            return fireScheduledActionQueue().then(\r\n\t                function onQueueResolve(result) {\r\n\t                    if (settings.logTime) {\r\n\t                        var receivedTime = new Date();\r\n\t                        var delta = Number(receivedTime - sentTime) / 1000;\r\n\t                        $log.info(\"Sync Transaction Time: \" + delta + \" seconds.\");\r\n\t\r\n\t                    }\r\n\t                    processingActions = false;\r\n\t                    return result;\r\n\t\r\n\t                },\r\n\t                function onQueueReject(reason) {\r\n\t                    $log.error('Action Queue was Rejected');\r\n\t                    isScheduled = false;\r\n\t                    tail = $q.when(true);\r\n\t                    processingActions = false;\r\n\t                    return $q.reject(reason);\r\n\t\r\n\t                }\r\n\t            );\r\n\t\r\n\t        }\r\n\t\r\n\t        /**\r\n\t         * New variant of fireActionQueue that uses the queue of action infos,\r\n\t         * \twhich are in order of decreasing precedence.\r\n\t         * Creates a chain of primises: start with an empty defer, and add each\r\n\t         *  function as a \"then\" to execute when the previous promise completes.\r\n\t         * The whole chain is constructed, then the head of the chain is resolved, \r\n\t         * \tletting the execution begin.\r\n\t         * \t\r\n\t         * @return {promise} the last promise in the chain\r\n\t         */\r\n\t        function fireScheduledActionQueue() {\r\n\t            var queue = $q.defer(),\r\n\t                pendingDeferreds = [],\r\n\t                pendingPromises = [],\r\n\t                nextActionInfo,\r\n\t                nextPromise;\r\n\t\r\n\t            nextPromise = queue.promise;\r\n\t            for (var actionIndex = 0; actionIndex < scheduledActionQueue.length; actionIndex++) {\r\n\t                nextActionInfo = scheduledActionQueue[actionIndex];\r\n\t                nextPromise = nextPromise.then(nextActionInfo.action);\r\n\t                pendingDeferreds.push(nextActionInfo.deferred);\r\n\t                pendingPromises.push(nextPromise);\r\n\t                nextActionInfo.isScheduled = false; //Allow future scheduling\r\n\t                nextActionInfo.deferred = null;\r\n\t\r\n\t            }\r\n\t            // Resolve all promises created during enqueue.\r\n\t            $q.all(pendingPromises).then(\r\n\t                function resolvePending(allResults) {\r\n\t                    for (var dfdIndex = 0; dfdIndex < pendingDeferreds.length; dfdIndex++) {\r\n\t                        if (pendingDeferreds[dfdIndex]) {\r\n\t                            pendingDeferreds[dfdIndex].resolve(allResults[dfdIndex]);\r\n\t                        }\r\n\t                    }\r\n\t                },\r\n\t                function rejectPending(reason) {\r\n\t                    for (var dfdIndex = 0; dfdIndex < pendingDeferreds.length; dfdIndex++) {\r\n\t                        if (pendingDeferreds[dfdIndex]) {\r\n\t                            pendingDeferreds[dfdIndex].reject(reason);\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            );\r\n\t            scheduledActionQueue = [];\r\n\t            queue.resolve();\r\n\t            return nextPromise;\r\n\t\r\n\t        }\r\n\t        return service;\r\n\t    }];\r\n\t})();\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\t(function() {\r\n\t    module.exports = ['$provide', function($provide) {\r\n\t        /*\r\n\t         * This decorator intercepts the creation $q service to add pendingPromissesCount & pendingRemoteServiceCount.\r\n\t         */\r\n\t        $provide.decorator('$q', ['$delegate', '$rootScope', '$log', function($delegate, $rootScope, $log) {\r\n\t\r\n\t            /*\r\n\t             *\tTotal pending Prmosses Count\r\n\t             * Count is maintained through Overloaded Defered method and Finally handller.\r\n\t             */\r\n\t            var pendingPromisses = 0;\r\n\t\r\n\t            /*\r\n\t             *\tTotal pending Remote Services Count \r\n\t             * Count will be maintained through incremental and decrimental methods\r\n\t             * Incremental and Decrimental methods are consumed in RemoteService.js\r\n\t             */\r\n\t            var pendingRemoteServiceCount = 0;\r\n\t\r\n\t            var $q = $delegate;\r\n\t\r\n\t            /*\r\n\t             * Defer Method over loading for maintaining pendingPromissesCount\r\n\t             * It returns same promise ($q.defer()) object with finally handler to maintain pendingPromissesCount\r\n\t             */\r\n\t            var origDefer = $q.defer;\r\n\t\r\n\t            $q.defer = function() {\r\n\t                var defer = origDefer();\r\n\t                pendingPromisses++;\r\n\t\r\n\t                defer.promise.finally(function() {\r\n\t                    pendingPromisses--;\r\n\t                });\r\n\t\r\n\t                return defer;\r\n\t            };\r\n\t\r\n\t            $q.incrementRemoteServiceCount = function() {\r\n\t                pendingRemoteServiceCount++;\r\n\t            };\r\n\t\r\n\t            $q.decrementRemoteServiceCount = function() {\r\n\t                pendingRemoteServiceCount--;\r\n\t            };\r\n\t\r\n\t            $q.getPendingRemoteServiceCount = function() {\r\n\t                return pendingRemoteServiceCount;\r\n\t            };\r\n\t\r\n\t            $q.getPendingPromisses = function() {\r\n\t                return pendingPromisses;\r\n\t            };\r\n\t\r\n\t            return $q;\r\n\t        }]);\r\n\t\r\n\t    }];\r\n\t})();\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// adminService.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1c620c80e17b918674e8","(function() {\r\n    'use strict';\r\n    require('angular');\r\n    module.exports = angular.module('docGen.adminServices', [])\r\n        .provider('i18nService', require('./i18nService.js'))\r\n        .provider('RemoteService', require('./remoteService'))\r\n        .service('UtilService', require('./utilService'))\r\n        .service('ActionQueueService', require('./actionQueueService.js'))\r\n        .config(require('./queueWrapperService.js'));\r\n})();\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./adminService/docGenAdminService.module.js\n// module id = 1\n// module chunks = 0","module.exports = (__webpack_require__(3))(2);\n\n\n//////////////////\n// WEBPACK FOOTER\n// delegated ./node_modules/angular/index.js from dll-reference vendor_lib\n// module id = 2\n// module chunks = 0 1","module.exports = vendor_lib;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"vendor_lib\"\n// module id = 3\n// module chunks = 0 1","(function() {\r\n\tmodule.exports = [function() {\r\n\t\t\r\n\t\tvar provider = this;\r\n\t\t//Set defaults\r\n\t\tvar i18nData = {\r\n\t\t\t'CustomLabel': {},\r\n\t\t\t'CustomField': {},\r\n\t\t\t'dateFormat': 'MM/DD/YYYY',\r\n\t\t\t'dateTemplate': '12/31/1999',\r\n\t\t\t'currencyTemplate': '$1,234.00',\r\n\t\t\t'quantityTemplate': '1,234.00',\r\n\t\t\t'precision': {\r\n\t\t\t\t'currency': 2,\r\n\t\t\t\t'quantity': 2\r\n\t\t\t},\r\n\t\t\t'locale': 'en_US'\r\n\t\t};\r\n\r\n\t\tthis.$get = function() {\r\n\t\t\treturn new i18nService(i18nData);\r\n\r\n\t\t};\r\n\t\tprovider.setCustomLabel = function(newLabels) {\r\n\t\t\tangular.extend(i18nData.CustomLabel, newLabels);\r\n\t\t};\r\n\t\tprovider.setCustomField = function(newFields) {\r\n\t\t\tangular.extend(i18nData.CustomField, newFields);\r\n\t\t};\r\n\t\tprovider.setDateFormat = function(newFormat) {\r\n\t\t\tif (newFormat) {\r\n\t\t\t\ti18nData.dateFormat = newFormat;\r\n\t\t\t}\r\n\t\t};\r\n\t\tprovider.setLocale = function(newLocale) {\r\n\t\t\tif (newLocale) {\r\n\t\t\t\ti18nData.locale = newLocale;\r\n\t\t\t}\r\n\t\t};\r\n\t\tprovider.setPrecision = function(key, value) {\r\n\t\t\tif (typeof key === 'string' && angular.isDefined(value)) {\r\n\t\t\t\ti18nData.precision[key] = Number(value);\r\n\r\n\t\t\t} else if (typeof key === 'object') {\r\n\t\t\t\tangular.extend(i18nData.precision, key);\r\n\r\n\t\t\t}\r\n\t\t};\r\n\t\tprovider.setDateTemplate = function(newTemplate) {\r\n\t\t\tif (newTemplate) {\r\n\t\t\t\ti18nData.dateTemplate = newTemplate;\r\n\t\t\t}\r\n\t\t};\r\n\t\tprovider.setCurrencyTemplate = function(newTemplate) {\r\n\t\t\tif (newTemplate) {\r\n\t\t\t\ti18nData.currencyTemplate = newTemplate;\r\n\t\t\t}\r\n\t\t};\r\n\t\tprovider.setQuantityTemplate = function(newTemplate) {\r\n\t\t\tif (newTemplate) {\r\n\t\t\t\ti18nData.quantityTemplate = newTemplate;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction i18nService(i18nData) {\r\n\t\t\tvar service = i18nData;\r\n\t\t\tservice.currencySettings = buildNumberSettings(i18nData.currencyTemplate, i18nData.precision.currency);\r\n\t\t\tservice.quantitySettings = buildNumberSettings(i18nData.quantityTemplate, i18nData.precision.quantity);\r\n\t\t\tservice.dateSettings = buildDateSettings(i18nData.dateTemplate);\r\n\t\t\tservice.timeZoneOffset = (new Date()).getTimezoneOffset() * 60 * 1000;\r\n\t\t\treturn service;\r\n\r\n\t\t\tfunction buildNumberSettings(template, precision) {\r\n\t\t\t\tvar settings = {\r\n\t\t\t\t\tsymbol: '',\r\n\t\t\t\t\tisSymbolBefore: true,\r\n\t\t\t\t\tseparator: ',',\r\n\t\t\t\t\tgroupLength: 3,\r\n\t\t\t\t\tdecimal: '.',\r\n\t\t\t\t\tprecision: angular.isNumber(precision) ? precision : 2,\r\n\t\t\t\t\tgroupingExp: undefined\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Regex for capturing groups of number separators\r\n\t\t\t\t * Matched groups: \r\n\t\t\t\t *      0      ignore     1          2        3        4       5     ignore     6    \t\t\t \t\t\t\r\n\t\t\t\t * [Symbol(s)][spaces][digit(s)][separator][digits][decimal][digits][spaces][Symbol(s)]\r\n\t\t\t\t */\r\n\t\t\t\tvar templateRegex = /^(\\D*)(?:\\s*)([\\d\\.\\,\\'\\s\\-]+)([\\.\\,\\'\\s\\-])(\\d{3,4})(\\.|\\,)(\\d{2,})(?:\\s*)(\\D*)$/;\r\n\t\t\t\tvar matches = template.match(templateRegex);\r\n\t\t\t\tif (matches) {\r\n\t\t\t\t\t//Discard first element -- the full string match\r\n\t\t\t\t\tmatches.shift();\r\n\t\t\t\t\t//Check symbol and where it was matched\r\n\t\t\t\t\tif (matches[0]) {\r\n\t\t\t\t\t\tsettings.symbol = matches[0];\r\n\t\t\t\t\t\tsettings.isSymbolBefore = true;\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsettings.symbol = matches[6];\r\n\t\t\t\t\t\tsettings.isSymbolBefore = false;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//Get the rest of the matches\r\n\t\t\t\t\tsettings.separator = matches[2];\r\n\t\t\t\t\tsettings.groupLength = matches[3].length;\r\n\t\t\t\t\tsettings.decimal = matches[4];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Compile the grouping regexp for fast reuse\r\n\t\t\t\t * Matching groups: \r\n\t\t\t\t *        0               1         ignored         2\r\n\t\t\t\t * [leading digits][grouped digits][decimal][fraction digits]\r\n\t\t\t\t */\r\n\t\t\t\tvar regexpStr = '^(\\\\d{1,' + settings.groupLength + '})?' + '((?:\\\\d{' + settings.groupLength + '})*)' + '(?:[\\.\\,](\\\\d*))?$';\r\n\t\t\t\tsettings.groupingExp = new RegExp(regexpStr);\r\n\t\t\t\treturn settings;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Construct settings required for date rendering. May turn this into\r\n\t\t\t * \ta way of making salesforce date format compatible with the 'moment'\r\n\t\t\t * \tlibrary so that the date filter can take advantage of moment.\r\n\t\t\t * \t \r\n\t\t\t */\r\n\t\t\tfunction buildDateSettings(dateTemplate) {\r\n\t\t\t\tvar settings = {\r\n\t\t\t\t\tseparator: '/',\r\n\t\t\t\t\tordering: ['mm', 'dd', 'yyyy'],\r\n\t\t\t\t\tgroupingExp: undefined\r\n\t\t\t\t};\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Regex for capturing date digits\r\n\t\t\t\t * Matched groups: \r\n\t\t\t\t *      0           1         2           ignore          3\r\n\t\t\t\t * [1-4 digits][separator][1|2 digits][same separator][2-4 digits]\r\n\t\t\t\t */\r\n\t\t\t\tvar templateRegex = /(\\d{1,4})([\\/\\s\\-\\.])(\\d{1,2})(?:\\2)(\\d{1,4})/;\r\n\t\t\t\tvar matches = dateTemplate.match(templateRegex);\r\n\t\t\t\tif (matches) {\r\n\t\t\t\t\t//Discard first element -- the full string match\r\n\t\t\t\t\tmatches.shift();\r\n\t\t\t\t\tsettings.separator = matches[1] || '/';\r\n\t\t\t\t\t[0, 2, 3].forEach(function(matchIndex, loopIndex) {\r\n\t\t\t\t\t\tvar digits = matches[matchIndex];\r\n\t\t\t\t\t\tvar component = '';\r\n\t\t\t\t\t\tvar str = '';\r\n\t\t\t\t\t\tvar numVal = Number(digits);\r\n\t\t\t\t\t\tif (numVal <= 12) {\r\n\t\t\t\t\t\t\tcomponent = 'm';\r\n\r\n\t\t\t\t\t\t} else if (numVal <= 31) {\r\n\t\t\t\t\t\t\tcomponent = 'd';\r\n\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcomponent = 'y';\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// TODO : .repeat method is part of ES6 and not compatible with IE and safari \r\n\t\t\t\t\t\t// settings.ordering[loopIndex] = component.repeat(digits.length);\r\n\r\n\t\t\t\t\t\t// put the simple logic instead of .repeat method to fix the issue\r\n\t\t\t\t\t\tfor (var i = 0; i < digits.length; i++) {\r\n\t\t\t\t\t\t\tstr += component;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tsettings.ordering[loopIndex] = str;\r\n\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t}\r\n\t\t\t\t/**\r\n\t\t\t\t * Compile the grouping regexp for fast reuse\r\n\t\t\t\t * Matching groups: \r\n\t\t\t\t *    ignored     0       ignored    1       ignored    2       ignored\r\n\t\t\t\t * [whitespace][digits][separator][digits][separator][digits][whitespace]\r\n\t\t\t\t */\r\n\t\t\t\tvar paddingExp = '\\\\s*';\r\n\t\t\t\tvar separatorExp = paddingExp + '\\\\' + settings.separator + '?' + paddingExp;\r\n\t\t\t\tvar regexpStr = ['^', paddingExp, '(\\\\d{1,4})', separatorExp, '(\\\\d{1,4})?', separatorExp, '(\\\\d{1,4})?', paddingExp, '$'].join('');\r\n\t\t\t\tsettings.groupingExp = new RegExp(regexpStr);\r\n\t\t\t\treturn settings;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}];\r\n\r\n\r\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./adminService/i18nService.js\n// module id = 4\n// module chunks = 0","(function() {\r\n    module.exports = [function() {\r\n\r\n        var provider = this;\r\n        var actionsMap = {};\r\n        var redirectOnFail = '/';\r\n        var trackAllRemoteCalls = false;\r\n\r\n        provider.setRemoteActions = function(newActions) {\r\n            \r\n            angular.extend(actionsMap, newActions);\r\n            return provider;\r\n        };\r\n\r\n        provider.setRedirectLocation = function(newLocation) {\r\n            redirectOnFail = newLocation ? newLocation : false;\r\n            return provider;\r\n        };\r\n\r\n        provider.setTrackAllRemoteCalls = function(isEnabled) {\r\n            trackAllRemoteCalls = isEnabled;\r\n            return provider;\r\n        };\r\n\r\n        function RemoteServiceFactory($q, $log, $window) {\r\n            return new RemoteService($q, $log, $window, actionsMap, redirectOnFail);\r\n\r\n        }\r\n\r\n        RemoteServiceFactory.$inject = ['$q', '$log', '$window'];\r\n        \r\n        this.$get = RemoteServiceFactory;\r\n\r\n        function RemoteService($q, $log, $window, RemoteActions, redirectOnFail) {\r\n            var service = {};\r\n            var lastTransaction = {};\r\n            initRemoteActionFunctions();\r\n            return service;\r\n\r\n            function initRemoteActionFunctions() {\r\n                var actionKey, actionName, isProp, isStr;\r\n                for (actionKey in RemoteActions) {\r\n                    isProp = RemoteActions.hasOwnProperty(actionKey);\r\n                    isStr = typeof actionKey === 'string';\r\n                    if (isProp && isStr) {\r\n                        actionConfig = getRemoteActionConfig(actionKey);\r\n                        service[actionKey] = createRemoteActionFunction(actionConfig);\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            /*\r\n             * This method will check RemoteAction[key] contains action string or action config object\r\n             * according to that it will create actionConfig object and returns it \r\n             */\r\n            function getRemoteActionConfig(actionKey) {\r\n                var config = {};\r\n\r\n                if (angular.isDefined(RemoteActions[actionKey])) {\r\n                    var actionConf = RemoteActions[actionKey];\r\n                    if (angular.isString(actionConf)) {\r\n                        config.actionName = actionConf;\r\n                        config.skipLoader = false;\r\n\r\n                    } else if (angular.isObject(actionConf)) {\r\n                        config.actionName = (angular.isDefined(actionConf.actionName)) ? actionConf.actionName : null;\r\n                        config.skipLoader = (angular.isDefined(actionConf.skipLoader)) ? actionConf.skipLoader : false;\r\n\r\n                    }\r\n\r\n                }\r\n                return config;\r\n            }\r\n\r\n            /**\r\n             * Used for generating methods that can be called on the service by the name\r\n             * \tdeclared in the RemoteActions object.\r\n             * Each method passes its fully-qualified name and its\r\n             * \targuments to invokeRemoteAction. The arguments passed\r\n             * \tto this function should just match the signature of \r\n             * \tthe Apex method. \r\n             * @return {promise} resolves with the result of the remote action\r\n             */\r\n            function createRemoteActionFunction(actionConfig) {\r\n                var actionFunction = function() {\r\n                    return invokeRemoteAction(actionConfig, arguments);\r\n\r\n                };\r\n                return actionFunction;\r\n\r\n            }\r\n            /**\r\n             * Helper for calling visualforce remoting. \r\n             *  \r\n             * @param \t{string}\tactionName \tthe remote action to invoke\r\n             * @param \t{array}\t\tactionParams\tany number of parameters to pass to remote\r\n             *          \t\t\t\t\t\t\t\t\t\t\t\taction before callback \r\n             * @return {promise} a $q promise that resolves with result of remote action\r\n             *\r\n             * Example: \r\n             * \t\t<code>\r\n             * \t\tvar thenable = invokeRemoteAction(RemoteActions.getCartLineItems, [cartRequest]);\r\n             * \t\tthenable.then(function (result) {\r\n             * \t\t\tuseResult(result);\r\n             * \t\t});\r\n             * \t\t</code>\r\n             * Here, thenable will be a promise that gets resolved with the result of the remote action \r\n             */\r\n            function invokeRemoteAction(actionConfig, actionParams) {\r\n                // $log.debug('invokeRemoteAction-->'+actionConfig.actionName, actionParams);\r\n                \r\n                //Constuct deferred object for return\r\n                var deferred, errorMessage, remoteActionWithParams, resolver, remotingParams, actionName;\r\n                deferred = $q.defer();\r\n                actionName = actionConfig.actionName;\r\n\r\n                setRemoteServiceCount(actionConfig, true);\r\n\r\n                if (!actionName || typeof actionName !== 'string') {\r\n                    errorMessage = \"Error - Could not invoke remote action: action name invalid!\";\r\n                    $log.error(errorMessage);\r\n                    deferred.reject(errorMessage);\r\n                    return deferred.promise;\r\n\r\n                }\r\n                //Construct list with aciton name and parameters to pass to invokeAction\r\n                remoteActionWithParams = [actionName];\r\n                for (var argIndex = 0, nextArg; argIndex < actionParams.length; argIndex++) {\r\n                    nextArg = actionParams[argIndex];\r\n                    /*if (!nextArg) {\r\n                        errorMessage = \"Error - Could not construct remote action parameters. Parameter #\" + argIndex + \" is undefined!\";\r\n                        $log.error(errorMessage);\r\n                        deferred.reject(errorMessage);\r\n                        return deferred.promise;\r\n\r\n                    }*/\r\n                    remoteActionWithParams.push(nextArg);\r\n\r\n                }\r\n                //Add the resolve function and remoting params to argument array\r\n                resolver = function resolveRemoteAction(result, event) {\r\n                    if (event.status) {\r\n                        if(result !== null) {\r\n\t                        $log.debug('Resolved \"' + actionName + '\"' +\r\n\t                                   ', Time taken: ' + result.timeTaken / 1000 + ' sec.' +\r\n\t                                   ', Query count: ' + result.queryCount);\r\n\r\n\t                        if (result.timeDetail) {\r\n\t\t                        $log.debug('Timings for ' + actionName, result.timeDetail);\r\n\t                        }\r\n                        }\r\n\r\n                        deferred.resolve(result);\r\n\r\n                    } else {\r\n                        errorMessage = 'Error - Could not resolve remote action: ' + actionName;\r\n                        $log.error(errorMessage, actionParams, event.message);\r\n                        //Currently the only way to check whether request failed due to user logout\r\n                        var isLoggedOut = event.message.toLowerCase().indexOf('logged') >= 0;\r\n                        if (isLoggedOut && redirectOnFail) {\r\n                            $window.location.href = redirectOnFail;\r\n\r\n                        }\r\n                        deferred.reject(event);\r\n\r\n                    }\r\n\r\n                    setRemoteServiceCount(actionConfig, false);\r\n                };\r\n                remoteActionWithParams.push(resolver);\r\n\r\n                //Add the default parameters for remoting call\r\n                remotingParams = {\r\n                    \"buffer\": false,\r\n                    \"escape\": false,\r\n                    \"timeout\": 120000\r\n                };\r\n                remoteActionWithParams.push(remotingParams);\r\n\r\n                //Try to call visualforce remoting invokeAction with the parameters we built \r\n                try {\r\n                    Visualforce.remoting.Manager.invokeAction.apply(Visualforce.remoting.Manager, remoteActionWithParams);\r\n\r\n                } catch (ex) {\r\n                    errorMessage = 'Error - Could not invoke remote action: ' + actionName;\r\n                    $log.error(errorMessage, actionParams, ex);\r\n                    deferred.reject(errorMessage);\r\n\r\n                }\r\n                return deferred.promise;\r\n\r\n            }\r\n\r\n            /*\r\n             * This method sets pendingRemoteServiceCount of $q service (decorrated in queueWrapperService.js) \r\n             * based on actionConfig.skip and LoggerLevel\r\n             */\r\n            function setRemoteServiceCount(actionConfig, incrementFlag) {\r\n                //$log.debug('setRemoteServiceCount-->', actionConfig, incrementFlag);\r\n                if (!actionConfig.skipLoader || trackAllRemoteCalls) {\r\n                    if (incrementFlag) {\r\n                        $q.incrementRemoteServiceCount();\r\n\r\n                    } else {\r\n                        $q.decrementRemoteServiceCount();\r\n\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n    }];\r\n\r\n})();\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./adminService/remoteService.js\n// module id = 5\n// module chunks = 0","(function() {\r\n    module.exports = ['lodash', function(_) {\r\n        var service = this;\r\n\r\n        service.frequencyConstants = {\r\n            FREQUENCY_HOURLY: 'Hourly',\r\n            FREQUENCY_DAILY: 'Daily',\r\n            FREQUENCY_WEEKLY: 'Weekly',\r\n            FREQUENCY_MONTHLY: 'Monthly',\r\n            FREQUENCY_QUARTERLY: 'Quarterly',\r\n            FREQUENCY_HALFYEARLY: 'Half Yearly',\r\n            FREQUENCY_YEARLY: 'Yearly'\r\n        };\r\n\r\n        service.priceTypesConstants = {\r\n            PRICETYPE_ONETIME: 'One Time',\r\n            PRICETYPE_RECURRING: 'Recurring',\r\n            PRICETYPE_USAGE: 'Usage',\r\n            PRICETYPE_INCLUDED_USAGE: 'Included Usage'\r\n        };\r\n\r\n        /**\r\n         * Use string-to-number conversion to compensate for floating point \r\n         * \terrors in standard javascript rounding.\r\n         * @param  {Number/String} value\r\n         * @param  {Number/String} precision \tthese can be numbers or strings\r\n         *                                    representing numbers\r\n         * @return {Number}\tRounded value\r\n         */\r\n        service.round = function(value, precision) {\r\n            precision = precision ? precision : 0;\r\n            var roundExpPos = \"e+\" + precision;\r\n            var roundExpNeg = \"e-\" + precision;\r\n            return Number(Math.round(value + roundExpPos) + roundExpNeg);\r\n\r\n        };\r\n\r\n        /**\r\n         * Check whether a nmber is within a min/max range. If min or max is not\r\n         * \tof type number, it the value is assumed to automatically meet the \r\n         * \tcriteria. If the value to check is not a number type, it automatically\r\n         * \tfails.\r\n         * @param  {Number}  minVal    \r\n         * @param  {Number}  maxVal    \r\n         * @param  {Number}  betweenVal\r\n         * @param  {Boolean}  strictly\t\tWhether to compare strictly. False by default.\r\n         * @return {Boolean}           \r\n         */\r\n        service.isBetween = function(minVal, maxVal, betweenVal, strictly) {\r\n            if (!angular.isNumber(betweenVal)) {\r\n                return false;\r\n\r\n            }\r\n            var minSatisfied, maxSatisfied;\r\n            if (!strictly) {\r\n                minSatisfied = angular.isNumber(minVal) ? betweenVal >= minVal : true;\r\n                maxSatisfied = angular.isNumber(maxVal) ? betweenVal <= maxVal : true;\r\n\r\n            } else {\r\n                minSatisfied = angular.isNumber(minVal) ? betweenVal > minVal : true;\r\n                maxSatisfied = angular.isNumber(maxVal) ? betweenVal < maxVal : true;\r\n\r\n            }\r\n            return minSatisfied && maxSatisfied;\r\n\r\n        };\r\n\r\n        /**\r\n         * Replicate Java string format where you can pass an string that has\r\n         * \tgroups such as {0}, {1}, ... and an array of strings to insert at\r\n         * \tthe appropriate indicies. Used for filling in custom labels.\r\n         * @param  {[type]} baseString [description]\r\n         * @param  {[type]} inserts    [description]\r\n         * @return {[type]}            [description]\r\n         */\r\n        service.stringFormat = function(baseString, inserts) {\r\n            if (!baseString) {\r\n                return '';\r\n\r\n            }\r\n            if (!angular.isArray(inserts)) {\r\n                return baseString;\r\n\r\n            }\r\n            var stringGroups = baseString.split(/\\{(\\d+)\\}/),\r\n                formattedString = '',\r\n                isInsert = false,\r\n                insertIndex = 0,\r\n                nextInsert = '';\r\n            for (var stringIndex = 0; stringIndex < stringGroups.length; stringIndex++) {\r\n                if (isInsert) {\r\n                    isInsert = false;\r\n                    insertIndex = parseInt(stringGroups[stringIndex]);\r\n                    nextInsert = insertIndex < inserts.length ? inserts[insertIndex] : '';\r\n                    formattedString += nextInsert;\r\n\r\n                } else {\r\n                    isInsert = true;\r\n                    formattedString += stringGroups[stringIndex];\r\n\r\n                }\r\n\r\n            }\r\n            return formattedString;\r\n\r\n        };\r\n\r\n        /**\r\n         * returns true when the parameter passed is undefined or null or empty array or blank string\r\n         * @param obj any kind of parameter \r\n         */\r\n        service.isEmpty = function(obj) {\r\n            if (angular.isDefined(obj) && obj !== null) {\r\n                if (angular.isArray(obj) && obj.length === 0 || obj === '') {\r\n                    return true;\r\n\r\n                }\r\n                return false;\r\n\r\n            }\r\n            return true;\r\n\r\n        };\r\n\r\n        /**\r\n         * Construct a date object in which the time is set to 12:00 AM GMT.\r\n         * This is used to match salesforce UTC milliseconds standard for dates.\r\n         * \r\n         * @param  {Number} year  year as numerical value\r\n         * @param  {Number} month month value, where January = 0\r\n         * @param  {Number} date  date as numerical value\r\n         * @return {Date}\r\n         */\r\n        service.newUTCDate = function(year, month, date) {\r\n            var newDate = new Date();\r\n            newDate.setUTCHours(0, 0, 0);\r\n            if (angular.isNumber(year)) {\r\n                newDate.setUTCFullYear(year);\r\n\r\n            }\r\n            if (angular.isNumber(month)) {\r\n                newDate.setUTCMonth(month);\r\n\r\n            }\r\n            if (angular.isNumber(date)) {\r\n                newDate.setUTCDate(date);\r\n\r\n            }\r\n            return newDate;\r\n\r\n        };\r\n\r\n        /**\r\n         * Computes the new date for adding days to the given date \r\n         * @param date current date\r\n         * @param days number of days to add\r\n         * @return the new date\r\n         */\r\n        service.addDays = function(date, days) {\r\n            return date + 86400000 * days;\r\n        };\r\n\r\n        /**\r\n         * Computes the end date for the given start date and term parameters\r\n         * @param startDate the term start date\r\n         * @param term the term \r\n         * @param frequency the frequency associated with the term\r\n         * @return the end date\r\n         */\r\n        service.computeEndDate = function(startDate, term, frequency) {\r\n            var newEndDate = new Date(startDate);\r\n\r\n            if (frequency === service.frequencyConstants.FREQUENCY_HOURLY) {\r\n                // hourly\r\n                newEndDate = newEndDate.setDate(newEndDate.getDate() + (1 / 24 * term));\r\n\r\n            } else if (frequency === service.frequencyConstants.FREQUENCY_DAILY) {\r\n                // daily\r\n                newEndDate = newEndDate.setDate(newEndDate.getDate() + term);\r\n\r\n            } else if (frequency === service.frequencyConstants.FREQUENCY_WEEKLY) {\r\n                // weekly\r\n                newEndDate = newEndDate.setDate(newEndDate.getDate() + (term * 7));\r\n\r\n            } else if (frequency === service.frequencyConstants.FREQUENCY_MONTHLY) {\r\n                // monthly\r\n                newEndDate = service.computeEndDateByMonths(startDate, term, 1);\r\n\r\n            } else if (frequency === service.frequencyConstants.FREQUENCY_QUARTERLY) {\r\n                // quarterly\r\n                newEndDate = service.computeEndDateByMonths(startDate, term, 3);\r\n\r\n            } else if (frequency === service.frequencyConstants.FREQUENCY_HALFYEARLY) {\r\n                // half yearly\r\n                newEndDate = service.computeEndDateByMonths(startDate, term, 6);\r\n\r\n            } else if (frequency === service.frequencyConstants.FREQUENCY_YEARLY) {\r\n                // yearly\r\n                newEndDate = service.computeEndDateByMonths(startDate, term, 12);\r\n\r\n            } else {\r\n                //Added for app to not break as start date from ms is converted to date object\r\n                newEndDate = startDate;\r\n            }\r\n\r\n            return newEndDate;\r\n\r\n        };\r\n\r\n        /**\r\n         * compute end date for monthly, quartely, half-yearly or yearly term \r\n         * @param startDate line item start date\r\n         * @param term number of months plus extra days / 30 \r\n         * @param frequencyInMonths 1-monthly, 3-quarterly 6-half-yearly 12-yearly \r\n         */\r\n        service.computeEndDateByMonths = function(startDate, term, frequencyInMonths) {\r\n            var months = (term * frequencyInMonths);\r\n\r\n            var newEndDate = new Date(startDate);\r\n            newEndDate = newEndDate.setMonth(newEndDate.getMonth() + months);\r\n\r\n            var dateToFindDays = new Date(newEndDate);\r\n            dateToFindDays = dateToFindDays.setDate(dateToFindDays.getDate() + 1);\r\n\r\n            var daysInMonths = service.daysInMonth(new Date(dateToFindDays).getFullYear(), new Date(dateToFindDays).getMonth());\r\n            var remainingTerms = ((term * frequencyInMonths) - months);\r\n            var extraDays = Math.round(remainingTerms * daysInMonths);\r\n\r\n            newEndDate = new Date(newEndDate);\r\n            newEndDate = newEndDate.setDate(newEndDate.getDate() + (extraDays - 1));\r\n\r\n            return newEndDate;\r\n        };\r\n\r\n        /**\r\n         * reorder elements within an array such that when a matching key is found, the element is moved to the \r\n         * head of that array - this check is repeated for every element of the array.\r\n         * @param - source array\r\n         * @param - predicate, callback function; Must return true if element should move to the head of the array\r\n         */\r\n        service.reorderArray = function(array, callback) {\r\n            if (_.isArray(array) === false || array.length === 0 || _.isFunction(callback) === false) {\r\n                return;\r\n            }\r\n\r\n            var spliceIdx = [];\r\n\r\n            for (var i = 0; i < array.length; i++) {\r\n                // callback should return true/false\r\n                if ((i > 1) && callback(array[i])) {\r\n                    spliceIdx.push(i);\r\n                }\r\n            }\r\n\r\n            spliceIdx.forEach(function(idx) {\r\n                var culled = array.splice(idx, 1);\r\n                array.splice(0, 0, culled[0]);\r\n            });\r\n        };\r\n\r\n        /**\r\n         * compute days in given year and a month\r\n         * @param year\r\n         * @param month\r\n         * return days in month\r\n         */\r\n        service.daysInMonth = function(year, month) {\r\n            return new Date(year, month, 0).getDate();\r\n        };\r\n\r\n        service.removeTempUIAttributes = function(obj) {\r\n            Object.keys(obj).forEach(function(key) {\r\n                if (_.startsWith(key, '@@') || _.startsWith(key, '$$')) {\r\n                    delete obj[key];\r\n                } else if (angular.isObject(obj[key])) {\r\n                    service.removeTempUIAttributes(obj[key]);\r\n                }\r\n            });\r\n        };\r\n\r\n        service.validateEndDate = function(date) {\r\n            var now = new Date();\r\n            if (now.getTime() > date) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n\r\n        service.validateDate = function(date) {\r\n            var date_regex = /^(0[1-9]|1[0-2])\\/(0[1-9]|1\\d|2\\d|3[01])\\/(19|20)\\d{2}$/; //Validates the format (MM/DD/YYYY), with a year between 1900 and 2099\r\n            if (angular.isUndefined(date) || date === null) {\r\n                return false;\r\n            } else if (date.toString().trim().length < 1) {\r\n                return false;\r\n            } else if (date_regex.test(date)) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n\r\n        service.uniq = function(inputArray) {\r\n            var tempArray = [];\r\n            var tempObj = {};\r\n            _.forEach(inputArray, function(value, key) {\r\n                if (!tempObj[value.id]) {\r\n                    tempArray.push(value);\r\n                    tempObj[value.id] = value.id;\r\n                }\r\n            });\r\n            return tempArray;\r\n        };\r\n\r\n        service.intersection = function(inputArray) {\r\n            var tempArray = [];\r\n            _.forEach(inputArray, function(value, key) {\r\n                tempArray.push(value.actionArr);\r\n            });\r\n            return _.intersection.apply(_, tempArray);\r\n        };\r\n\r\n        /**\r\n         * Get the object corresponding to field name\r\n         * @param contextSO the \"starting\" sObject\r\n         * @param fieldAPIName the fully qualified field API name\r\n         * @return the object specified by fieldName\r\n         */\r\n        service.sObjectFromField = function(contextSO, fieldAPIName) {\r\n            //set new value\r\n            var path = fieldAPIName.split('.');\r\n            var curObject = contextSO;\r\n            for (var i = 0, max = path.length - 1; i < max; i++) {\r\n                if (typeof(curObject) !== 'undefined' && curObject !== null) {\r\n                    curObject = curObject[path[i]];\r\n                }\r\n            }\r\n\r\n            return curObject;\r\n        };\r\n\r\n        /**\r\n         * create popup for Product Information list\r\n         * @param product Object\r\n         */\r\n        service.createPopup = function(product) {\r\n            var infoURL = \"\";\r\n            if (product.productInformationList.length > 0) {\r\n                if (product.productInformationList[0].InformationType__c == \"Attached File\") {\r\n                    infoURL = \"/servlet/servlet.FileDownload?file=\" + product.productInformationList[0].FileId__c;\r\n\r\n                } else if (product.productInformationList[0].InformationType__c == \"Embedded Code\") {\r\n                    infoURL = product.productInformationList[0].EmbedCode__c;\r\n\r\n                } else if (product.productInformationList[0].InformationType__c == \"URL Address\") {\r\n                    infoURL = product.productInformationList[0].ContentUrl__c;\r\n\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            var header = product.productInformationList.length > 0 ? product.productInformationList[0].Name : \"\";\r\n            var isEmbed = product.productInformationList[0].InformationType__c == \"Embedded Code\" ? true : false;\r\n\r\n            if (infoURL === \"\" || infoURL === null) {\r\n                return false;\r\n            }\r\n\r\n            var url = isEmbed ? '' : infoURL;\r\n\r\n            var infoModal = window.open(url, 'Product Information', 'menubar=1,resizable=1,width=712,height=500');\r\n            if (isEmbed) {\r\n                infoModal.document.write('<html><head><title>Product Information</title></head>');\r\n                infoModal.document.write('<body><center><h3>' + header + '</h3>');\r\n                infoModal.document.write(infoURL);\r\n                infoModal.document.write('</center></body></html>');\r\n            }\r\n            if (window.focus) {\r\n                infoModal.focus();\r\n            }\r\n        };\r\n\r\n        return service;\r\n\r\n    }];\r\n})();\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./adminService/utilService.js\n// module id = 6\n// module chunks = 0","(function() {\r\n    module.exports = ['$q', '$log', function($q, $log) {\r\n\r\n        var service = this;\r\n        var isScheduled = false;\r\n        var processingActions = false;\r\n        var tail = $q.when(true);\r\n        var actionQueue = [];\r\n        var scheduledActionQueue = [];\r\n        var hashedActionsMap = {};\r\n        var settings = {\r\n            logTime: true,\r\n            maxPrecedence: 1024\r\n        };\r\n\r\n        /* -- Public methods -- */\r\n\r\n        //Used to register indiviudal actions and schedule them seperately\r\n        service.registerAction = registerAction;\r\n        service.scheduleAction = scheduleAction;\r\n        service.isProcessingActions = isProcessingActions;\r\n\r\n        /* -- Method Declarations -- */\r\n\r\n\r\n        /**\r\n         * Register a function in the action queue, optionally assignign it a \r\n         * \tprecedence in execution and a actionKey with which to hash. If the function\r\n         * \tparameter is not valid, does nothing. \r\n         *\r\n         * @param  {function}\tfunctionObject \tA function that can be executed by the queue.\r\n         * @param  {number}\t\tprecedence     \tPrecedence with which to execute function. \r\n         *                                   \tHigher = execute sooner\r\n         *                                   \tUndefined = Max (first)\r\n         * @param  {string} \tactionKey       Key with which to hash the function. If provided,\r\n         *                                   \tthe function is to be queued by this key instead\r\n         *                                   \tof by passing it as an object. Defaults to funciton.toString\r\n         * @return {actionQueue}              Reference to this service to allow chainging.\r\n         */\r\n        function registerAction(functionObject, precedence, actionKey) {\r\n            var hashVal, existed;\r\n            var max = settings.maxPrecedence;\r\n            if (!(functionObject instanceof Function)) {\r\n                return service;\r\n\r\n            }\r\n            //Calculate values\r\n            if (!angular.isNumber(precedence)) {\r\n                precedence = max;\r\n\r\n            } else {\r\n                precedence = Math.min(precedence, max);\r\n\r\n            }\r\n            hashVal = actionKey ? hashObject(actionKey) : hashObject(functionObject);\r\n            //Store information\r\n            //existed = hashedActionsMap[hashVal];\r\n            hashedActionsMap[hashVal] = {\r\n                \"action\": functionObject,\r\n                \"precedence\": precedence,\r\n                \"isScheduled\": false\r\n            };\r\n\r\n            return service;\r\n\r\n        }\r\n\r\n        /**\r\n         * Adapted from ActionFunctionQueue; converts any object into a string\r\n         * \tthat has a toString method then hashes that string to an integer value.\r\n         * \t\r\n         * @param  {object} \tobjectToHash\r\n         * @return {integer}  hashed integer value\r\n         */\r\n        function hashObject(objectToHash) {\r\n            var str = objectToHash.toString();\r\n            var hash = 5381;\r\n            for (i = 0; i < str.length; i++) {\r\n                char = str.charCodeAt(i);\r\n                hash = ((hash << 5) + hash) + char; /* hash * 33 + c */\r\n\r\n            }\r\n            return hash;\r\n\r\n        }\r\n\r\n\r\n        /**\r\n         * Schedule a particular action or array of actions. Actions should be \r\n         * \tin scheudled using the same function object or prototype with\r\n         * \twhich they were registered. \r\n         *\r\n         * Note: if parameter is an array, the order of actions does not influence\r\n         * \tthe order in which actions will be enqueued. Instead, the registered\r\n         * \tprecedence will be respected.\r\n         * \t\r\n         * @param {String|Function|Array} actionKey  action or collection of actions\r\n         * @return {promise} Resolves with the result of the action. Resolve waits until the queue finishes running.\r\n         */\r\n        function scheduleAction(actionKey) {\r\n            if (angular.isUndefined(actionKey) || actionKey === null) {\r\n                return tail;\r\n\r\n            }\r\n            var actionArr = [];\r\n            if (angular.isArray(actionKey)) {\r\n                actionArr = actionKey;\r\n\r\n            } else {\r\n                actionArr.push(actionKey);\r\n\r\n            }\r\n            var actionIndex, nextActionKey, newSchedule;\r\n            var resultPromises = [];\r\n            for (actionIndex = 0; actionIndex < actionArr.length; actionIndex += 1) {\r\n                nextActionKey = actionArr[actionIndex];\r\n                queuedResult = queueByPrecedence(nextActionKey);\r\n                if (queuedResult) {\r\n                    resultPromises.push(queuedResult);\r\n                }\r\n                if (!isScheduled) {\r\n                    isScheduled = true;\r\n                    tail = tail.then(fireSync);\r\n\r\n                }\r\n\r\n            }\r\n            if (resultPromises.length == 1) {\r\n                return resultPromises[0];\r\n\r\n            } else if (resultPromises.length > 1) {\r\n                return $q.all(resultPromises);\r\n\r\n            }\r\n            return tail;\r\n\r\n        }\r\n\r\n        /**\r\n         * Put a particular action's info into the queue.\r\n         * @param  {object} actionKey \tKey used to reference object\r\n         * @return {Boolean}           \tTrue if action becomes scheduled, else False.\r\n         */\r\n        function queueByPrecedence(actionKey) {\r\n            if (!actionKey) {\r\n                return false; //Invalid; do nothing.\r\n\r\n            }\r\n\r\n            var hashVal = hashObject(actionKey);\r\n            var actionInfo = hashedActionsMap[hashVal];\r\n            //Invalid or already scheduled.\r\n            if (!actionInfo) {\r\n                return false;\r\n\r\n            } else if (actionInfo.isScheduled) {\r\n                return actionInfo.deferred.promise;\r\n\r\n            }\r\n\r\n            var actionIndex = scheduledActionQueue.length; //add at the end for the least precendence action\r\n            for (var index = 0; index < scheduledActionQueue.length; ++index) {\r\n                var nextActionInfo = scheduledActionQueue[index];\r\n                if (actionInfo.precedence > nextActionInfo.precedence) {\r\n                    actionIndex = index;\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            scheduledActionQueue.splice(actionIndex, 0, actionInfo);\r\n            actionInfo.isScheduled = true;\r\n            actionInfo.deferred = $q.defer();\r\n            return actionInfo.deferred.promise;\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns true when the action function queue has begun processing actions, false when\r\n         * the queue has completed and is idle.\r\n         * @return {Boolean} True when actions are processing, false otherwise.\r\n         */\r\n        function isProcessingActions() {\r\n            return processingActions;\r\n\r\n        }\r\n\r\n        /**\r\n         * Fires a sync event. The new event is chained onto the tail of the\r\n         *  previous event, meaning events will run sequentially.\r\n         * If the actions in the queue are rejected, i.e. throw errors,\r\n         * \tthe tail of schedlued sync is reset, the rejection is returned.\r\n         * Optionally logs the information about how long the process took.\r\n         * \r\n         * @return {Promise} tail of scheduled queue\r\n         */\r\n        function fireSync() {\r\n            isScheduled = false;\r\n            processingActions = true;\r\n            var sentTime = new Date();\r\n            if (settings.logTime) {\r\n                $log.info(\"Action Queue Submitted: \" + sentTime.toGMTString());\r\n\r\n            }\r\n            //Build and run queue of actions\r\n            return fireScheduledActionQueue().then(\r\n                function onQueueResolve(result) {\r\n                    if (settings.logTime) {\r\n                        var receivedTime = new Date();\r\n                        var delta = Number(receivedTime - sentTime) / 1000;\r\n                        $log.info(\"Sync Transaction Time: \" + delta + \" seconds.\");\r\n\r\n                    }\r\n                    processingActions = false;\r\n                    return result;\r\n\r\n                },\r\n                function onQueueReject(reason) {\r\n                    $log.error('Action Queue was Rejected');\r\n                    isScheduled = false;\r\n                    tail = $q.when(true);\r\n                    processingActions = false;\r\n                    return $q.reject(reason);\r\n\r\n                }\r\n            );\r\n\r\n        }\r\n\r\n        /**\r\n         * New variant of fireActionQueue that uses the queue of action infos,\r\n         * \twhich are in order of decreasing precedence.\r\n         * Creates a chain of primises: start with an empty defer, and add each\r\n         *  function as a \"then\" to execute when the previous promise completes.\r\n         * The whole chain is constructed, then the head of the chain is resolved, \r\n         * \tletting the execution begin.\r\n         * \t\r\n         * @return {promise} the last promise in the chain\r\n         */\r\n        function fireScheduledActionQueue() {\r\n            var queue = $q.defer(),\r\n                pendingDeferreds = [],\r\n                pendingPromises = [],\r\n                nextActionInfo,\r\n                nextPromise;\r\n\r\n            nextPromise = queue.promise;\r\n            for (var actionIndex = 0; actionIndex < scheduledActionQueue.length; actionIndex++) {\r\n                nextActionInfo = scheduledActionQueue[actionIndex];\r\n                nextPromise = nextPromise.then(nextActionInfo.action);\r\n                pendingDeferreds.push(nextActionInfo.deferred);\r\n                pendingPromises.push(nextPromise);\r\n                nextActionInfo.isScheduled = false; //Allow future scheduling\r\n                nextActionInfo.deferred = null;\r\n\r\n            }\r\n            // Resolve all promises created during enqueue.\r\n            $q.all(pendingPromises).then(\r\n                function resolvePending(allResults) {\r\n                    for (var dfdIndex = 0; dfdIndex < pendingDeferreds.length; dfdIndex++) {\r\n                        if (pendingDeferreds[dfdIndex]) {\r\n                            pendingDeferreds[dfdIndex].resolve(allResults[dfdIndex]);\r\n                        }\r\n                    }\r\n                },\r\n                function rejectPending(reason) {\r\n                    for (var dfdIndex = 0; dfdIndex < pendingDeferreds.length; dfdIndex++) {\r\n                        if (pendingDeferreds[dfdIndex]) {\r\n                            pendingDeferreds[dfdIndex].reject(reason);\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n            scheduledActionQueue = [];\r\n            queue.resolve();\r\n            return nextPromise;\r\n\r\n        }\r\n        return service;\r\n    }];\r\n})();\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./adminService/actionQueueService.js\n// module id = 7\n// module chunks = 0","(function() {\r\n    module.exports = ['$provide', function($provide) {\r\n        /*\r\n         * This decorator intercepts the creation $q service to add pendingPromissesCount & pendingRemoteServiceCount.\r\n         */\r\n        $provide.decorator('$q', ['$delegate', '$rootScope', '$log', function($delegate, $rootScope, $log) {\r\n\r\n            /*\r\n             *\tTotal pending Prmosses Count\r\n             * Count is maintained through Overloaded Defered method and Finally handller.\r\n             */\r\n            var pendingPromisses = 0;\r\n\r\n            /*\r\n             *\tTotal pending Remote Services Count \r\n             * Count will be maintained through incremental and decrimental methods\r\n             * Incremental and Decrimental methods are consumed in RemoteService.js\r\n             */\r\n            var pendingRemoteServiceCount = 0;\r\n\r\n            var $q = $delegate;\r\n\r\n            /*\r\n             * Defer Method over loading for maintaining pendingPromissesCount\r\n             * It returns same promise ($q.defer()) object with finally handler to maintain pendingPromissesCount\r\n             */\r\n            var origDefer = $q.defer;\r\n\r\n            $q.defer = function() {\r\n                var defer = origDefer();\r\n                pendingPromisses++;\r\n\r\n                defer.promise.finally(function() {\r\n                    pendingPromisses--;\r\n                });\r\n\r\n                return defer;\r\n            };\r\n\r\n            $q.incrementRemoteServiceCount = function() {\r\n                pendingRemoteServiceCount++;\r\n            };\r\n\r\n            $q.decrementRemoteServiceCount = function() {\r\n                pendingRemoteServiceCount--;\r\n            };\r\n\r\n            $q.getPendingRemoteServiceCount = function() {\r\n                return pendingRemoteServiceCount;\r\n            };\r\n\r\n            $q.getPendingPromisses = function() {\r\n                return pendingPromisses;\r\n            };\r\n\r\n            return $q;\r\n        }]);\r\n\r\n    }];\r\n})();\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./adminService/queueWrapperService.js\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}