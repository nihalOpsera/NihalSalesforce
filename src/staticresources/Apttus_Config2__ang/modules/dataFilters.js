;(function() {
	//Currently defining each of these in this file. Best Practice: should be broken out
	angular
		.module('dataFilters', [])
		.filter('aptCurrency', ['dataTemplate', CurrencyFilter])
		.filter('aptDate', ['dataTemplate', DateFilter])
		.filter('aptQuantity', ['dataTemplate', QuantityFilter])
		.filter('aptPercentage', ['dataTemplate', PercentageFilter]);
	
	/**
	 * Filter Currency values based on dataTemplate from visualforce bindings.
	 * Note:	Initial implementation is very explicit in its steps. It is likely that 
	 * 				performance can be improved, at the expense of readability.
	 * @param {object} dataTemplate generated by dataTemplateFactory which extracts
	 *                              templates from the rendered page.
	 */
	function CurrencyFilter(dataTemplate) {
		var format = {
			symbol: '$',
			isSymbolBefore: true,
			separator: ',',
			groupLength: 3,
			decimal: '.',
			precision: dataTemplate.precision.currency || 2,
			groupingExp: undefined

		};

		function init() {
			//Ensure default filter values. 
			//This might be redundant b/c dataTemplateFactory sets defaults too.
			var currencyTemplate = dataTemplate.currency || '$1,234.56';
			/**
			 * Regex for capturing groups of number separators
			 * Matched groups: 
			 *      0      ignore     1          2        3        4       5     ignore     6    			 			
			 * [Symbol(s)][spaces][digit(s)][separator][digits][decimal][digits][spaces][Symbol(s)]
			 */
			var templateRegex = /^(\D*)(?:\s*)(\d+)([\.\,\'\s\-])(\d{3,4})(\.|\,)(\d{2,})(?:\s*)(\D*)$/;
			var matches = currencyTemplate.match(templateRegex);
			if (matches) {
				//Discard first element -- the full string match
				matches.shift();
				//Check symbol and where it was matched
				if (matches[0]) {
					format.symbol = matches[0];
					format.isSymbolBefore = true;

				} else {
					format.symbol = matches[6];
					format.isSymbolBefore = false;

				}
				//Get the rest of the matches
				format.separator = matches[2];
				format.groupLength = matches[3].length;
				format.decimal = matches[4];
			
			}

			/**
			 * Compile the grouping regexp for fast reuse
			 * Matching groups: 
			 *        0               1         ignored         2
			 * [leading digits][grouped digits][decimal][fraction digits]
			 */
			format.groupingExp = new RegExp("^(\\d{1," + format.groupLength + "})?" 
																			+ "((?:\\d{" + format.groupLength + "})*)" 
																			+ "(?:\\.?)(\\d*)$");

		}

		//Function that performs actual filter operation
		function filterInput(input) {
			//For now, just ignoring anything that can't be parsed as number
			var inputAsNumber = Number(input);
			if (isNaN(inputAsNumber)) {
				return input;

			}
			//Use toFixed to get string representation with correct padding & rounding
			var inputAsFixed = inputAsNumber.toFixed(format.precision);
			//Create regexp that matches group lengths based on template
			var matches = inputAsFixed.match(format.groupingExp);
			var inputFormatted = '';
			if (matches) {
				matches.shift();
				//Always take initial group of digits
				inputFormatted += matches[0];
				//Insert separators for interior numbers if they exist
				var toGroup = matches[1];
				if (toGroup) {
					for (var i = 0; i < toGroup.length; i++) {
						if (i % format.groupLength === 0) {
							inputFormatted += format.separator;

						}
						inputFormatted += toGroup[i];
					}

				}
				//If decimal exists, add decimal point and decimal
				if (matches[2]) {
					inputFormatted += format.decimal + matches[2];
					
				}
				//Prepend or append currency symbol
				if (format.isSymbolBefore) {
					inputFormatted = format.symbol + inputFormatted;

				} else {
					inputFormatted += format.symbol;

				}

			}
			return inputFormatted;

		}

		//Run the initialization
		init();
		//Return the constructed filter function.
		return filterInput;

	}

	/**
	 * Filter DateFilter values based on dataTemplate from visualforce bindings. 
	 * @param {object} dataTemplate generated by dataTemplateFactory which extracts
	 *                              templates from the rendered page.
	 */
	function DateFilter(dataTemplate) {
		//Create an example of an invalid date.
		var invalidDateStr = new Date("Invalid Date Example").toString();
		var format = {
			separator: '/',
			ordering: ['mm', 'dd', 'yyyy']
		};

		function init() {
			var dateTemplate = dataTemplate.date;
			/**
			 * Regex for capturing date digits
			 * Matched groups: 
			 *      0           1         2           ignore          3
			 * [1-4 digits][separator][1|2 digits][same seperator][2-4 digits]
			 */
			var templateRegex = /(\d{1,4})([\/\s\-\.])(\d{1,2})(?:\2)(\d{1,4})/;
			var matches = dateTemplate.match(templateRegex);
			if (matches) {
				//Discard first element -- the full string match
				matches.shift();
				format.separator = matches[1];
				[0,2,3].forEach(function(matchIndex, loopIndex) {
					var digits = matches[matchIndex];
					var component = '';
					var numVal = Number(digits);
					if (numVal <= 12) {
						component = 'm';

					} else if (numVal <= 31 ) {
						component = 'd';

					} else {
						component = 'y';

					}
					format.ordering[loopIndex] = component.repeat(digits.length);

				});
			
			}

		}

		function filterInput(input) {
			var inputAsDate = new Date(input);
			if (inputAsDate.toString() === invalidDateStr) {
				return input;

			}
			var inputOrdering = [];
			format.ordering.forEach(function(dateCode, index) {
				var letterCode = dateCode[0];
				//Default to day value
				var dateVal = inputAsDate.getDate().toString();
				if (letterCode === 'm') {
					dateVal = (1 + inputAsDate.getMonth()).toString();
					
				} else if (letterCode === 'y') {
					dateVal = inputAsDate.getFullYear().toString();

				}
				//Shorten or pad with zeroes
				if (dateVal.length > dateCode.length) {
					dateVal = dateVal.slice(dateVal.length - dateCode.length, dateVal.length);

				} else if (dateVal.length < dateCode.length) {
					dateVal = '0'.repeat(dateCode.length - dateVal.length) + dateVal;

				}
				inputOrdering[index] = dateVal;

			});
			return inputOrdering.join(format.separator);			

		}

		init();
		return filterInput;

	}

	/**
	 * Filter Quantity values based on dataTemplate from visualforce bindings. 
	 * @param {object} dataTemplate generated by dataTemplateFactory which extracts
	 *                              templates from the rendered page.
	 */
	function QuantityFilter(dataTemplate) {

		function filterInput(input) {
			var inputAsNumber = Number(input);
			if (isNaN(inputAsNumber)) {
				return input;

			}
			var inputAsFixed = inputAsNumber.toFixed(dataTemplate.precision.quantity);
			return inputAsFixed;

		}

		return filterInput;

	}

	/**
	 * Filter Percentage values based on dataTemplate from visualforce bindings. 
	 * @param {object} dataTemplate generated by dataTemplateFactory which extracts
	 *                              templates from the rendered page.
	 */
	function PercentageFilter(dataTemplate) {

		function filterInput(input) {
			var inputAsNumber = Number(input);
			if (isNaN(inputAsNumber)) {
				return input;

			}
			var inputAsFixed = inputAsNumber.toFixed(dataTemplate.precision.percentage);
			return inputAsFixed + '%';

		}

		return filterInput;

	}

})();